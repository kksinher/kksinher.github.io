<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是服软啊</title>
  
  
  <link href="https://kksinher.github.io/atom.xml" rel="self"/>
  
  <link href="https://kksinher.github.io/"/>
  <updated>2023-02-28T07:36:39.561Z</updated>
  <id>https://kksinher.github.io/</id>
  
  <author>
    <name>服软</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="https://kksinher.github.io/2023/02/28/MySQL/"/>
    <id>https://kksinher.github.io/2023/02/28/MySQL/</id>
    <published>2023-02-28T07:03:30.000Z</published>
    <updated>2023-02-28T07:36:39.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-面试题"><a href="#MySQL-面试题" class="headerlink" title="MySQL    面试题"></a>MySQL    面试题</h2><h3 id="1-MySQL-中有哪几种锁？"><a href="#1-MySQL-中有哪几种锁？" class="headerlink" title="1. MySQL 中有哪几种锁？"></a>1. MySQL 中有哪几种锁？</h3><ol><li><p>表级锁： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。</p></li><li><p>行级锁： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。</p></li><li><p>页面锁： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。 </p></li></ol><h3 id="2-MySQL-中有哪些不同的表格？"><a href="#2-MySQL-中有哪些不同的表格？" class="headerlink" title="2. MySQL 中有哪些不同的表格？"></a>2. MySQL 中有哪些不同的表格？</h3><p>共有 5 种类型的表格： </p><ol><li><p>MyISAM</p></li><li><p>Heap </p></li><li><p>Merge</p></li><li><p>INNODB</p></li><li><p>ISAM</p></li></ol><h3 id="3-简述在MySQL-数据库中-MyISAM-和InnoDB-的区别"><a href="#3-简述在MySQL-数据库中-MyISAM-和InnoDB-的区别" class="headerlink" title="3. 简述在MySQL 数据库中 MyISAM 和InnoDB 的区别"></a>3. 简述在MySQL 数据库中 MyISAM 和InnoDB 的区别</h3><h5 id="MyISAM："><a href="#MyISAM：" class="headerlink" title="MyISAM："></a>MyISAM：</h5><p>不支持事务， 但是每次查询都是原子的； 支持表级锁， 即每次操作是对整个表加锁； 存储表的总行数；</p><p>一个 MYISAM 表有三个文件： 索引文件. 表结构文件. 数据文件；</p><p>采用菲聚集索引，  索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致， 但是辅索引不用保证唯一性。 </p><h5 id="InnoDb："><a href="#InnoDb：" class="headerlink" title="InnoDb："></a>InnoDb：</h5><p>支持 ACID 的事务， 支持事务的四种隔离级别； 支持行级锁及外键约束： 因此可以支持写并发； <strong>不存储总行数：</strong></p><p>一个 InnoDb 引擎存储在一个文件空间（ 共享表空间， 表大小不受操作系统控制， 一个表可能分布在多个文件里）， 也有可能为多个（ 设置为独立表空， 表大小受操作系统文件大小限制， 一般为 2G）， 受操作系统文件大小的限制； </p><p>主键索引采用聚集索引（ 索引的数据域存储数据文件本身）， 辅索引的数据域存储主键的值； 因此从辅索引查找数据， 需要先通过辅索引找到主键值， 再访问辅索引； 最好使用自增主键， 防止插入数据时， 为维持 B+树结构， 文件的大调整。 </p><h3 id="4-MySQL-中InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#4-MySQL-中InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="4. MySQL 中InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>4. MySQL 中InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><p>SQL 标准定义的四个隔离级别为：</p><ol><li><p>read uncommited ： 读到未提交数据</p></li><li><p>read committed： 脏读， 不可重复读</p></li><li><p>repeatable read： 可重读</p></li><li><p>serializable ： 串行事物</p></li></ol><h3 id="5-CHAR-和VARCHAR-的区别？"><a href="#5-CHAR-和VARCHAR-的区别？" class="headerlink" title="5. CHAR 和VARCHAR 的区别？"></a>5. CHAR 和VARCHAR 的区别？</h3><ol><li><p>CHAR 和 VARCHAR 类型在存储和检索方面有所不同</p></li><li><p>CHAR 列长度固定为创建表时声明的长度， 长度值范围是 1 到 255 当 CHAR 值被存储时， 它们被用空格填充到特定长度， 检索 CHAR 值时需删除尾随空格。</p></li></ol><h3 id="6-主键和候选键有什么区别？"><a href="#6-主键和候选键有什么区别？" class="headerlink" title="6. 主键和候选键有什么区别？"></a>6. 主键和候选键有什么区别？</h3><p>表格的每一行都由主键唯一标识,一个表只有一个主键。</p><p>主键也是候选键。按照惯例， 候选键可以被指定为主键， 并且可以用于任何外键引用。</p><h3 id="7-myisamchk-是用来做什么的？"><a href="#7-myisamchk-是用来做什么的？" class="headerlink" title="7. myisamchk 是用来做什么的？"></a>7. myisamchk 是用来做什么的？</h3><p>它用来压缩 MyISAM 表， 这减少了磁盘或内存使用。</p><h5 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h5><p>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT， BLOB 等字段， 以适应不同长度的数据类型。</p><p>MyISAM Static 在受损情况下更容易恢复。</p><h3 id="8-如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#8-如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="8. 如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>8. 如果一个表有一列定义为TIMESTAMP，将发生什么？</h3><p>每当行被更改时， 时间戳字段将获取当前时间戳。</p><h5 id="列设置为-AUTO-INCREMENT-时，-如果在表中达到最大值，-会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，-如果在表中达到最大值，-会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时， 如果在表中达到最大值， 会发生什么情况？"></a>列设置为 AUTO INCREMENT 时， 如果在表中达到最大值， 会发生什么情况？</h5><p>它会停止递增， 任何进一步的插入都将产生错误， 因为密钥已被使用。</p><h5 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h5><p>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值， 并且不需要指定表名称。</p><h3 id="9-你怎么看到为表格定义的所有索引？"><a href="#9-你怎么看到为表格定义的所有索引？" class="headerlink" title="9. 你怎么看到为表格定义的所有索引？"></a>9. 你怎么看到为表格定义的所有索引？</h3><p>索引是通过以下方式为表格定义的：</p><p>SHOW INDEX FROM <tablename>;</tablename></p><h3 id="10-LIKE-声明中的％和-是什么意思？"><a href="#10-LIKE-声明中的％和-是什么意思？" class="headerlink" title="10. LIKE 声明中的％和_是什么意思？"></a>10. LIKE 声明中的％和_是什么意思？</h3><p>％ 对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。 </p><h5 id="如何在-Unix-和-MySQL-时间戳之间进行转换？"><a href="#如何在-Unix-和-MySQL-时间戳之间进行转换？" class="headerlink" title="如何在 Unix 和 MySQL 时间戳之间进行转换？"></a>如何在 Unix 和 MySQL 时间戳之间进行转换？</h5><p>UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令 </p><h3 id="11-列对比运算符是什么？"><a href="#11-列对比运算符是什么？" class="headerlink" title="11. 列对比运算符是什么？"></a>11. 列对比运算符是什么？</h3><p>在 SELECT 语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND， OR 或 LIKE 运算符。 </p><h3 id="12-BLOB-和TEXT-有什么区别？"><a href="#12-BLOB-和TEXT-有什么区别？" class="headerlink" title="12. BLOB 和TEXT 有什么区别？"></a>12. BLOB 和TEXT 有什么区别？</h3><p>BLOB 是一个二进制对象， 可以容纳可变数量的数据。TEXT 是一个不区分大小写的 BLOB。 </p><p>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写， 对 TEXT 值不区分大小写。 </p><h3 id="13-MySQL-fetch-array-和MySQL-fetch-object-的区别是什么？"><a href="#13-MySQL-fetch-array-和MySQL-fetch-object-的区别是什么？" class="headerlink" title="13. MySQL_fetch_array 和MySQL_fetch_object 的区别是什么？"></a>13. MySQL_fetch_array 和MySQL_fetch_object 的区别是什么？</h3><p>以下是 MySQL_fetch_array 和 MySQL_fetch_object 的区别：</p><p>MySQL_fetch_array（ ） – 将结果行作为关联数组或来自数据库的常规数组返回。 MySQL_fetch_object – 从数据库返回结果行作为对象。</p><h3 id="14-MyISAM-表格将在哪里存储，并且还提供其存储格式？"><a href="#14-MyISAM-表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="14. MyISAM 表格将在哪里存储，并且还提供其存储格式？"></a>14. MyISAM 表格将在哪里存储，并且还提供其存储格式？</h3><p>每个 MyISAM 表格以三种格式存储在磁盘上：</p><p>· “.frm” 文件存储表定义</p><p>· 数据文件具有“.MYD” （ MYData） 扩展名索引文件具有“.MYI” （ MYIndex） 扩展名</p><h3 id="15-MySQL-如何优化DISTINCT？"><a href="#15-MySQL-如何优化DISTINCT？" class="headerlink" title="15. MySQL 如何优化DISTINCT？"></a>15. MySQL 如何优化DISTINCT？</h3><p>DISTINCT 在所有列上转换为 GROUP BY， 并与 ORDER BY 子句结合使用。SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;</p><h3 id="16-如何显示前-50-行？"><a href="#16-如何显示前-50-行？" class="headerlink" title="16. 如何显示前 50 行？"></a>16. 如何显示前 50 行？</h3><p>在 MySQL 中， 使用以下代码查询显示前 50 行： SELECT*FROM</p><p>LIMIT 0,50;</p><h3 id="17-可以使用多少列创建索引？"><a href="#17-可以使用多少列创建索引？" class="headerlink" title="17. 可以使用多少列创建索引？"></a>17. 可以使用多少列创建索引？</h3><p>任何标准表最多可以创建 16 个索引列。</p><h3 id="18-NOW（）和-CURRENT-DATE（）有什么区别？"><a href="#18-NOW（）和-CURRENT-DATE（）有什么区别？" class="headerlink" title="18. NOW（）和 CURRENT_DATE（）有什么区别？"></a>18. NOW（）和 CURRENT_DATE（）有什么区别？</h3><p>NOW（） 命令用于显示当前年份， 月份， 日期， 小时， 分钟和秒。CURRENT_DATE（） 仅显示当前年份， 月份和日期。</p><h3 id="19-什么是非标准字符串类型？"><a href="#19-什么是非标准字符串类型？" class="headerlink" title="19. 什么是非标准字符串类型？"></a>19. 什么是非标准字符串类型？</h3><ol><li><p>TINYTEXT</p></li><li><p>TEXT</p></li><li><p>MEDIUMTEXT</p></li><li><p>LONGTEXT</p></li></ol><h3 id="20-什么是通用-SQL-函数？"><a href="#20-什么是通用-SQL-函数？" class="headerlink" title="20. 什么是通用 SQL 函数？"></a>20. 什么是通用 SQL 函数？</h3><ol><li><p>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。</p></li><li><p>FORMAT(X, D)- 格式化数字 X 到 D 有效数字。</p></li><li><p>CURRDATE(), CURRTIME()-  返回当前日期或时间。</p></li><li><p>NOW（） – 将当前日期和时间作为一个值返回。</p></li><li><p>MONTH（）， DAY（ ）， YEAR（）， WEEK（）， WEEKDAY（） – 从日期值中提取给定数据。</p></li><li><p>HOUR（）， MINUTE（）， SECOND（） – 从时间值中提取给定数据。</p></li><li><p>DATEDIFF（ A， B） – 确定两个日期之间的差异， 通常用于计算年龄</p></li><li><p>SUBTIMES（ A， B） – 确定两次之间的差异。</p></li><li><p>FROMDAYS（ INT） – 将整数天数转换为日期值。</p></li></ol><h3 id="21-MySQL-支持事务吗？"><a href="#21-MySQL-支持事务吗？" class="headerlink" title="21. MySQL 支持事务吗？"></a>21. MySQL 支持事务吗？</h3><p>在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交， 所以在缺省情况下， MySQL 是不支持事务的。</p><p>但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话， 你的MySQL 就可以使用事务处理,使用 SET</p><p>AUTOCOMMIT=0 就可以使 MySQL 允许在非 autocommit 模式， 在非</p><p>autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的更改。</p><h3 id="22-MySQL-里记录货币用什么字段类型好"><a href="#22-MySQL-里记录货币用什么字段类型好" class="headerlink" title="22. MySQL 里记录货币用什么字段类型好"></a>22. MySQL 里记录货币用什么字段类型好</h3><p>NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型， 这在 SQL92 标准允许。他们被用于保存值， 该值的准确精度是极其重要的值， 例如与金钱有关的数据。当声明一个类是这些类型之一时， 精度和规模的能被(并且通常是)指定。</p><p>例如：</p><p>salary DECIMAL(9,2)</p><p>在这个例子中， 9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。</p><p>因此， 在这种情况下， 能被存储在 salary 列中的值的范围是从-9999999.99 到9999999.99。</p><h3 id="23-MySQL-有关权限的表都有哪几个？"><a href="#23-MySQL-有关权限的表都有哪几个？" class="headerlink" title="23. MySQL 有关权限的表都有哪几个？"></a>23. MySQL 有关权限的表都有哪几个？</h3><p>MySQL 服务器通过权限表来控制用户对数据库的访问， 权限表存放在 MySQL 数据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv， columns_priv 和 host。</p><h3 id="24-列的字符串类型可以是什么？"><a href="#24-列的字符串类型可以是什么？" class="headerlink" title="24. 列的字符串类型可以是什么？"></a>24. 列的字符串类型可以是什么？</h3><p>字符串类型是：</p><ol><li><p>SET</p></li><li><p>BLOB</p></li><li><p>ENUM</p></li><li><p>CHAR</p></li><li><p>TEXT</p></li></ol><h3 id="25-MySQL-数据库作发布系统的存储，一天五万条以上的增量，-预计运维三年-怎么优化？"><a href="#25-MySQL-数据库作发布系统的存储，一天五万条以上的增量，-预计运维三年-怎么优化？" class="headerlink" title="25. MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？"></a>25. MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？</h3><ol><li><p>设计良好的数据库结构， 允许部分数据冗余， 尽量避免 join 查询， 提高效率。</p></li><li><p>选择合适的表字段数据类型和存储引擎， 适当的添加索引。</p></li><li><p>MySQL 库主从读写分离。</p></li><li><p>找规律分表， 减少单表中的数据量提高查询速度。</p></li><li><p>添加缓存机制， 比如 memcached， apc 等。</p></li><li><p>不经常改动的页面， 生成静态页面。</p></li><li><p>书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</p></li></ol><h3 id="26-锁的优化策略"><a href="#26-锁的优化策略" class="headerlink" title="26. 锁的优化策略"></a>26. 锁的优化策略</h3><ol><li><p>读写分离</p></li><li><p>分段加锁</p></li><li><p>减少锁持有的时间</p></li><li><p>多个线程尽量以相同的顺序去获取资源</p></li></ol><p>不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。</p><h3 id="27-索引的底层实现原理和优化"><a href="#27-索引的底层实现原理和优化" class="headerlink" title="27. 索引的底层实现原理和优化"></a>27. 索引的底层实现原理和优化</h3><p>B+树， 经过优化的 B+树</p><p>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针， 因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。</p><h3 id="28-什么情况下设置了索引但无法使用"><a href="#28-什么情况下设置了索引但无法使用" class="headerlink" title="28. 什么情况下设置了索引但无法使用"></a>28. 什么情况下设置了索引但无法使用</h3><ol><li><p>以“ %” 开头的 LIKE 语句， 模糊匹配</p></li><li><p>OR 语句前后没有同时使用索引</p></li><li><p>数据类型出现隐式转化（ 如 varchar不加单引号的话可能会自动转换为 int 型）</p></li></ol><h3 id="29-实践中如何优化-MySQL"><a href="#29-实践中如何优化-MySQL" class="headerlink" title="29. 实践中如何优化 MySQL"></a>29. 实践中如何优化 MySQL</h3><p>最好是按照以下顺序优化： </p><ol><li><p>SQL 语句及索引的优化</p></li><li><p>数据库表结构的优化</p></li><li><p>系统配置的优化</p></li><li><p>硬件的优化</p></li></ol><p>详细可以查看 <a href="http://youzhixueyuan.com/MySQL-slow-query-optimization-index-optimization.html">阿里 P8 架构师谈：MySQL 慢查询优化. 索引优化. 以及表等优化</a>总结</p><h3 id="30-优化数据库的方法"><a href="#30-优化数据库的方法" class="headerlink" title="30. 优化数据库的方法"></a>30. 优化数据库的方法</h3><ol><li><p>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’ 省份’ . ’ 性别’ 最好适用 ENUM</p></li><li><p>使用连接(JOIN)来代替子查</p></li><li><p>适用联合(UNION)来代替手动创建的临时表</p></li><li><p>事务处理</p></li><li><p>锁定表. 优化事务处理</p></li><li><p>适用外键， 优化锁定表</p></li><li><p>建立索引</p></li><li><p>优化查询语句</p></li></ol><h3 id="31-简单描述-MySQL-中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"><a href="#31-简单描述-MySQL-中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）" class="headerlink" title="31. 简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"></a>31. 简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）</h3><p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)， 它们包含着对数据表里所有记录的引用指针。</p><p>普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。</p><p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值， 在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。也就是说， 唯一索引可以保证数据记录的唯一性。</p><p>主键， 是一种特殊的唯一索引， 在一张表中只能定义一个主键索引， 主键用于唯一标识一条记录， 使用关键字 PRIMARY KEY 来创建。</p><p>索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。</p><p>索引可以极大的提高数据的查询速度， 但是会降低插入. 删除. 更新表的速度， 因为在执行这些写操作时， 还要操作索引文件。</p><h3 id="32-数据库中的事务是什么"><a href="#32-数据库中的事务是什么" class="headerlink" title="32. 数据库中的事务是什么?"></a>32. 数据库中的事务是什么?</h3><p>事务（ transaction） 是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功， 则认为事务成功， 即使只有一个操作失败， 事务也不成功。如果所有操作完成， 事务则提交， 其修改将作用于所有其他数据库进程。如果一个操作失败， 则事务将回滚， 该事务所有操作的影响都将取消。</p><h5 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h5><ol><li><p>原子性： 即不可分割性， 事务要么全部被执行， 要么就全部不被执行。</p></li><li><p>一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态</p></li><li><p>隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何  其他事务，</p></li><li><p>持久性。事务正确提交后， 其结果将永久保存在数据库中， 即使在事务提交后有了其他故障， 事务的处理结果也会得到保存。</p></li></ol><p>或者这样理解：</p><p>事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组， 如果任何一个语句操作失败那么整个操作就被失败， 以后操作就会回滚到操作前状态， 或者是上有个节点。为了确保要么执行， 要么不执行， 就可以使用事务。要将有组语句作为事务考虑， 就需要通过 ACID 测试， 即原子性， 一致性， 隔离性和持久性。</p><h3 id="33-SQL-注入漏洞产生的原因？如何防止？"><a href="#33-SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="33. SQL 注入漏洞产生的原因？如何防止？"></a>33. SQL 注入漏洞产生的原因？如何防止？</h3><p>SQL 注入产生的原因： 程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</p><p>防止 SQL 注入的方式：</p><p>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</p><p>执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。</p><p>过滤掉 sql 语句中的一些关键词： update. insert. delete. select.  * 。</p><p>提高数据库表和字段的命名技巧， 对一些重要的字段根据程序的特点命名， 取不易被猜到的。</p><h3 id="34-为表中得字段选择合适得数据类型"><a href="#34-为表中得字段选择合适得数据类型" class="headerlink" title="34. 为表中得字段选择合适得数据类型"></a>34. 为表中得字段选择合适得数据类型</h3><p>字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text</p><p>优先考虑数字类型， 其次是日期或者二进制类型， 最后是字符串类型， 同级别得数据类型， 应该优先选择占用空间小的数据类型</p><h3 id="35-存储时期"><a href="#35-存储时期" class="headerlink" title="35. 存储时期"></a>35. 存储时期</h3><p>Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间， 精确到秒， 占用 8 个字节得存储空间， datatime 类型与时区无关</p><p>Timestamp:以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19， 显示依赖于所指定得时区， 默认在第一个列行的数据修改时可以自动得修改</p><p>timestamp 列得值</p><p>Date:（ 生日） 占用得字节数比使用字符串.datatime.int 储存要少， 使用 date 只需要 3 个字节， 存储日期月份， 还可以利用日期时间函数进行日期间得计算</p><p>Time:存储时间部分得数据</p><p>注意:不要使用字符串类型来存储日期时间数据（ 通常比字符串占用得储存空间小， 在进行查找过滤可以利用日期得函数）</p><p>使用 int 存储日期时间不如使用 timestamp 类型</p><h3 id="36-对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："><a href="#36-对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：" class="headerlink" title="36. 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："></a>36. 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：</h3><ol><li>索引的目的是什么？</li></ol><p>快速访问数据表中的特定信息， 提高检索速度</p><p>创建唯一性索引， 保证数据库表中每一行数据的唯一性。加速表和表之间的连接</p><p>使用分组和排序子句进行数据检索时，  可以显著减少查询中分组和排序的时间</p><ol start="2"><li>索引对数据库系统的负面影响是什么？</li></ol><p>负面影响：</p><p>创建索引和维护索引需要耗费时间， 这个时间随着数据量的增加而增加； 索引需要占用物理空间， 不光是表需要占用数据空间， 每个索引也需要占用物理空间； 当对表进行增. 删. 改. 的时候索引也要动态维护，  这样就降低了数据的维护速度。</p><ol start="3"><li>为数据表建立索引的原则有哪些？</li></ol><p>在最频繁使用的. 用以缩小查询范围的字段上建立索引。 在频繁使用的. 需要排序的字段上建立索引</p><ol start="4"><li>什么情况下不宜建立索引？</li></ol><p>对于查询中很少涉及的列或者重复值比较多的列， 不宜建立索引。对于一些特殊的数据类型， 不宜建立索引， 比如文本字段（ text） 等</p><h3 id="37-解释-MySQL-外连接-内连接与自连接的区别"><a href="#37-解释-MySQL-外连接-内连接与自连接的区别" class="headerlink" title="37. 解释 MySQL 外连接. 内连接与自连接的区别"></a>37. 解释 MySQL 外连接. 内连接与自连接的区别</h3><p>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p><p>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中， 即内连接只连接匹配的行。</p><p>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表. 右表或两个表中</p><p>的所有数据行， 这三种情况依次称之为左外连接， 右外连接， 和全外连接。</p><p>左外连接， 也称左连接， 左表为主表， 左表中的所有记录都会出现在结果集中， 对于那些在右表中并没有匹配的记录， 仍然要显示， 右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换， MySQL 目前还不支持全外连接。</p><h3 id="38-Myql-中的事务回滚机制概述"><a href="#38-Myql-中的事务回滚机制概述" class="headerlink" title="38. Myql 中的事务回滚机制概述"></a>38. Myql 中的事务回滚机制概述</h3><p>事务是用户定义的一个数据库操作序列， 这些操作要么全做要么全不做， 是一个不可分割的工作单位，  事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p><p>要同时修改数据库中两个不同表时， 如果它们不是一个事务的话， 当第一个表修改完， 可能第二个表修改过程中出现了异常而没能修改， 此时就只有第二个表依旧是未修改之前的状态， 而第一个表已经被修改完毕。而当你把它们设定为一个</p><p>事务的时候， 当第一个表修改完， 第二表修改出现异常而没能修改， 第一个表和第二个表都要回到未修改的状态， 这就是所谓的事务回滚 </p><h3 id="39-SQL-语言包括哪几部分？每部分都有哪些操作关键字？"><a href="#39-SQL-语言包括哪几部分？每部分都有哪些操作关键字？" class="headerlink" title="39. SQL 语言包括哪几部分？每部分都有哪些操作关键字？"></a>39. SQL 语言包括哪几部分？每部分都有哪些操作关键字？</h3><p>SQL 语言包括数据定义(DDL). 数据操纵(DML),数据控制(DCL)和数据查询（ DQL） 四个部分。</p><p>数据定义： Create Table,Alter Table,Drop Table, Craete/Drop Index 等数据操纵： Select ,insert,update,delete,</p><p>数据控制： grant,revoke 数据查询： select</p><h3 id="40-完整性约束包括哪些？"><a href="#40-完整性约束包括哪些？" class="headerlink" title="40. 完整性约束包括哪些？"></a>40. 完整性约束包括哪些？</h3><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><h6 id="分为以下四类："><a href="#分为以下四类：" class="headerlink" title="分为以下四类："></a>分为以下四类：</h6><ol><li><p>实体完整性： 规定表的每一行在表中是惟一的实体。</p></li><li><p>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括  取值范围. 精度等规定。</p></li><li><p>参照完整性：  是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性， 防止了数据丢失或无意义的数据在数据库中扩散。 </p></li><li><p>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需  要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件， 它反映某一具体应用必须满足的语义要求。</p></li></ol><p>与表有关的约束：包括列约束(NOT NULL（ 非空约束）)和表约束(PRIMARY KEY. foreign key. check. UNIQUE) 。 </p><h3 id="41-什么是锁？"><a href="#41-什么是锁？" class="headerlink" title="41. 什么是锁？"></a>41. 什么是锁？</h3><p>答： 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时， 在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可  能会读取和存储不正确的数据， 破坏数据库的一致性。 </p><p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进  行操作前， 先向系统发出请求， 对其加锁。加锁后事务就对该数据对象有了一定的控制， 在该事务释放锁之前， 其他的事务不能对此数据对象进行更新操作。 </p><h5 id="基本锁类型：-锁包括行级锁和表级锁"><a href="#基本锁类型：-锁包括行级锁和表级锁" class="headerlink" title="基本锁类型： 锁包括行级锁和表级锁"></a>基本锁类型： 锁包括行级锁和表级锁</h5><h3 id="42-什么叫视图？游标是什么？"><a href="#42-什么叫视图？游标是什么？" class="headerlink" title="42. 什么叫视图？游标是什么？"></a>42. 什么叫视图？游标是什么？</h3><p>答： 视图是一种虚拟的表， 具有和物理表相同的功能。可以对视图进行增， 改， 查， 操作， 视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易， 相比多表查询。</p><p>游标：  是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，  从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标， 但是需要逐条处理数据的时候， 游标显得十分重要。 </p><h3 id="43-什么是存储过程？用什么来调用？"><a href="#43-什么是存储过程？用什么来调用？" class="headerlink" title="43. 什么是存储过程？用什么来调用？"></a>43. 什么是存储过程？用什么来调用？</h3><p>答： 存储过程是一个预编译的 SQL 语句， 优点是允许模块化的设计， 就是说只需创建一次， 以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL， 使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。</p><h3 id="44-如何通俗地理解三个范式？"><a href="#44-如何通俗地理解三个范式？" class="headerlink" title="44. 如何通俗地理解三个范式？"></a>44. 如何通俗地理解三个范式？</h3><p>答：第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</p><p>第三范式： 3NF 是对字段冗余性的约束， 即任何字段不能由其他字段派生出来， 它要求字段没有冗余。。</p><h5 id="范式化设计优缺点"><a href="#范式化设计优缺点" class="headerlink" title="范式化设计优缺点:"></a>范式化设计优缺点:</h5><p><strong>优点:</strong></p><p>可以尽量得减少数据冗余， 使得更新快， 体积小</p><p><strong>缺点</strong>:</p><p>对于查询需要多个表进行关联， 减少写得效率增加读得效率， 更难进行索引优化</p><h5 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化:"></a>反范式化:</h5><p>优点:可以减少表得关联， 可以更好得进行索引优化</p><p>缺点:数据冗余以及数据异常， 数据得修改需要更多的成本</p><h3 id="45-什么是基本表？什么是视图？"><a href="#45-什么是基本表？什么是视图？" class="headerlink" title="45. 什么是基本表？什么是视图？"></a>45. 什么是基本表？什么是视图？</h3><p>答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中， 是一个虚表</p><h3 id="46-试述视图的优点？"><a href="#46-试述视图的优点？" class="headerlink" title="46. 试述视图的优点？"></a>46. 试述视图的优点？</h3><p>答： (1)  视图能够简化用户的操作    (2) 视图使用户能以多种角度看待同一数据；</p><p>(3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。</p><h3 id="47-NULL-是什么意思"><a href="#47-NULL-是什么意思" class="headerlink" title="47.  NULL 是什么意思"></a>47.  NULL 是什么意思</h3><p>答： NULL 这个值表示 UNKNOWN(未知):它不表示“” (空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较， 并在逻辑上希望获得一个答案。</p><p>使用 IS NULL 来进行 NULL 判断</p><h3 id="48-主键-外键和索引的区别？"><a href="#48-主键-外键和索引的区别？" class="headerlink" title="48. 主键. 外键和索引的区别？"></a>48. 主键. 外键和索引的区别？</h3><p>主键. 外键和索引的区别</p><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>主键– 唯一标识一条记录， 不能有重复的， 不允许为空 </p><p>外键– 表的外键是另一表的主键, 外键可以有重复的, 可以是空值索引– 该字段没有重复值， 但可以有一个空值</p><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>主键– 用来保证数据完整性 </p><p>外键– 用来和其他表建立联系用的索引– 是提高查询排序的速度</p><h5 id="个数："><a href="#个数：" class="headerlink" title="个数："></a>个数：</h5><p>主键– 主键只能有一个 </p><p>外键– 一个表可以有多个外键 </p><p>索引– 一个表可以有多个唯一索引 </p><h3 id="49-你可以用什么来确保表格里的字段只接受特定范围里的值"><a href="#49-你可以用什么来确保表格里的字段只接受特定范围里的值" class="headerlink" title="49. 你可以用什么来确保表格里的字段只接受特定范围里的值?"></a>49. 你可以用什么来确保表格里的字段只接受特定范围里的值?</h3><p>答： Check 限制， 它在数据库表格里被定义， 用来限制输入该列的值。 </p><p>触发器也可以被用来限制数据库表格里的字段能够接受的值，  但是这种办法要求触发器在表格里被定义， 这可能会在某些情况下影响到性能。 </p><h3 id="50-说说对-SQL-语句优化有哪些方法？（选择几条）"><a href="#50-说说对-SQL-语句优化有哪些方法？（选择几条）" class="headerlink" title="50. 说说对 SQL 语句优化有哪些方法？（选择几条）"></a>50. 说说对 SQL 语句优化有哪些方法？（选择几条）</h3><ol><li><p>Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。</p></li><li><p>用 EXISTS 替代 IN. 用 NOT EXISTS 替代 NOT IN。</p></li><li><p> 避免在索引列上使用计算</p></li><li><p>避免在索引列上使用 IS NULL 和 IS NOT NULL</p></li><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断， 否则将导致引擎放弃使用索引而进行全表扫描</p></li><li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p></li></ol><h3 id="51-MySQL数据库的乐观锁和悲观锁"><a href="#51-MySQL数据库的乐观锁和悲观锁" class="headerlink" title="51. MySQL数据库的乐观锁和悲观锁"></a>51. MySQL数据库的乐观锁和悲观锁</h3><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-面试题&quot;&gt;&lt;a href=&quot;#MySQL-面试题&quot; class=&quot;headerlink&quot; title=&quot;MySQL    面试题&quot;&gt;&lt;/a&gt;MySQL    面试题&lt;/h2&gt;&lt;h3 id=&quot;1-MySQL-中有哪几种锁？&quot;&gt;&lt;a href=&quot;#1-My</summary>
      
    
    
    
    <category term="MySQL 面试" scheme="https://kksinher.github.io/categories/MySQL-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="MySQL" scheme="https://kksinher.github.io/tags/MySQL/"/>
    
    <category term="乐观锁" scheme="https://kksinher.github.io/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
    <category term="悲观锁" scheme="https://kksinher.github.io/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
    <category term="B+树" scheme="https://kksinher.github.io/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://kksinher.github.io/2023/02/28/Redis/"/>
    <id>https://kksinher.github.io/2023/02/28/Redis/</id>
    <published>2023-02-28T06:32:22.000Z</published>
    <updated>2023-02-28T06:51:12.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-面试题"><a href="#Redis-面试题" class="headerlink" title="Redis    面试题"></a>Redis    面试题</h2><h3 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1. 什么是Redis?"></a>1. 什么是Redis?</h3><p>Redis 是完全开源免费的，遵守 BSD 协议， 是一个高性能的 key-value 数据库。</p><h5 id="Redis-与其他-key-value-缓存产品有以下三个特点："><a href="#Redis-与其他-key-value-缓存产品有以下三个特点：" class="headerlink" title="Redis 与其他 key - value 缓存产品有以下三个特点："></a>Redis 与其他 key - value 缓存产品有以下三个特点：</h5><ol><li><p>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p></li><li><p>Redis 不仅仅支持简单的 key-value 类型的数据， 同时还提供 list， set， zset， hash 等数据结构的存储。</p></li><li><p>Redis 支持数据的备份， 即 master-slave 模式的数据备份。</p></li></ol><h5 id="Redis-优-势"><a href="#Redis-优-势" class="headerlink" title="Redis 优 势"></a>Redis 优 势</h5><p>性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。</p><p>丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及Ordered Sets 数据类型操作。</p><p>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</p><p>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</p><h5 id="Redis-与其他-key-value-存储有什么不同？"><a href="#Redis-与其他-key-value-存储有什么不同？" class="headerlink" title="Redis 与其他 key-value 存储有什么不同？"></a>Redis 与其他 key-value 存储有什么不同？</h5><p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明， 无需进行额外的抽象。</p><p>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存， 因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时， 在磁盘格式方面他们是紧凑的以追加的方式产生的， 因为他们并不需要进行随机访问。</p><h3 id="2-Redis-的数据类型？"><a href="#2-Redis-的数据类型？" class="headerlink" title="2. Redis 的数据类型？"></a>2. Redis 的数据类型？</h3><p>答： Redis 支持五种数据类型： string（ 字符串），hash（ 哈希）， list（ 列表）， set（ 集合） 及 zsetsorted set： 有序集合)。</p><p>我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog. Geo. Pub/Sub。</p><p>如果你说还玩过 edis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p><h3 id="3-使用Redis-有哪些好处？"><a href="#3-使用Redis-有哪些好处？" class="headerlink" title="3. 使用Redis 有哪些好处？"></a>3. 使用Redis 有哪些好处？</h3><ol><li><p>速度快， 因为数据存在内存中， 类似于 HashMap， HashMap 的优势就是查找和操作的时间复杂度都是 O1)</p></li><li><p>支持丰富数据类型， 支持 string， list， set， Zset， hash 等</p></li><li><p>支持事务， 操作都是原子性， 所谓的原子性就是对数据的更改要么全部执行， 要么全部不执行</p></li><li><p>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除</p></li></ol><h3 id="4-Redis-相比Memcached-有哪些优势？"><a href="#4-Redis-相比Memcached-有哪些优势？" class="headerlink" title="4. Redis 相比Memcached 有哪些优势？"></a>4. Redis 相比Memcached 有哪些优势？</h3><ol><li><p>Memcached 所有的值均是简单的字符串， redis 作为其替代者， 支持更为丰富的数据类</p></li><li><p>Redis 的速度比 Memcached 快很3. Redis 可以持久化其数据</p></li></ol><h3 id="5-Memcache-与Redis-的区别都有哪些？"><a href="#5-Memcache-与Redis-的区别都有哪些？" class="headerlink" title="5. Memcache 与Redis 的区别都有哪些？"></a>5. Memcache 与Redis 的区别都有哪些？</h3><ol><li><p>存储方式 Memecache 把数据全部存在内存之中， 断电后会挂掉， 数据不能超过内存大小。 Redis 有部份存在硬盘上， 这样能保证数据的持久性。</p></li><li><p>数据支持类型 Memcache 对数据类型支持相对简单。 Redis 有复杂的数据类型。</p></li><li><p>使用底层模型不同 它们之间底层实现方式  以及与客户端之间通信的应用协议不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话， 会浪费一定的时间去移动和请求。</p></li></ol><h3 id="6-Redis-是单进程单线程的？"><a href="#6-Redis-是单进程单线程的？" class="headerlink" title="6. Redis 是单进程单线程的？"></a>6. Redis 是单进程单线程的？</h3><p>答： Redis 是单进程单线程的， redis 利用队列技术将并发访问变为串行访问， 消除了传统数据库串行控制的开销。</p><h3 id="7-一个字符串类型的值能存储最大容量是多少？"><a href="#7-一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="7. 一个字符串类型的值能存储最大容量是多少？"></a>7. 一个字符串类型的值能存储最大容量是多少？</h3><p>答： 512M</p><h3 id="8-Redis-的持久化机制是什么？各自的优缺点？"><a href="#8-Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="8. Redis 的持久化机制是什么？各自的优缺点？"></a>8. Redis 的持久化机制是什么？各自的优缺点？</h3><h5 id="Redis-提供两种持久化机制-RDB-和-AOF-机制"><a href="#Redis-提供两种持久化机制-RDB-和-AOF-机制" class="headerlink" title="Redis 提供两种持久化机制 RDB 和 AOF 机制:"></a>Redis 提供两种持久化机制 RDB 和 AOF 机制:</h5><ol><li>RDBRedis DataBase)持久化方式： 是指用数据集快照的方式半持久化模式) 记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件， 持久化结束后， 用这个临时文件替换上次持久化的文件， 达到数据恢复。</li></ol><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li><p>只有一个文件 dump.rdb， 方便持久化。</p></li><li><p>容灾性好， 一个文件可以保存到安全的磁盘。</p></li><li><p>性能最大化， fork 子进程来完成写操作， 让主进程继续处理命令， 所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能) 4.相对于数据集大时， 比 AOF 的启动效率更高。</p></li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障， 会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p></li><li><p>AOFAppend-only file)持久化方式： 是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。</p></li></ol><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol><li><p>数据安全， aof 持久化可以配置 appendfsync 属性， 有 always， 每进行一次命令操作就记录到 aof 文件中一次。</p></li><li><p>通过 append 模式写文件， 即使中途服务器宕机， 可以通过 redis-check-aof 工具解决数据一致性问题。</p></li><li><p>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（ 文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（ 比如误操作的 flushall）)</p></li></ol><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol><li><p>AOF 文件比 RDB 文件大， 且恢复速度慢。</p></li><li><p>数据集大的时候， 比 rdb 启动效率低。</p></li></ol><h3 id="9-Redis-常见性能问题和解决方案："><a href="#9-Redis-常见性能问题和解决方案：" class="headerlink" title="9. Redis 常见性能问题和解决方案："></a>9. Redis 常见性能问题和解决方案：</h3><ol><li><p>Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数， 会阻塞主线程的工作， 当快照比较大时对性能影响是非常大的， 会间断性暂停服务</p></li><li><p>如果数据比较重要， 某个 Slave 开启 AOF 备份数据， 策略设置为每秒同步一</p></li><li><p>为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网</p></li><li><p>尽量避免在压力很大的主库上增加从</p></li><li><p>主从复制不要用图状结构， 用单向链表结构更为稳定， 即：Master &lt;- Slave1</p></li></ol><p>&lt;- Slave2 &lt;- Slave3 … 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了， 可以立刻启用 Slave1 做 Master， 其他不变。</p><h3 id="10-redis-过期键的删除策略？"><a href="#10-redis-过期键的删除策略？" class="headerlink" title="10. redis 过期键的删除策略？"></a>10. redis 过期键的删除策略？</h3><ol><li><p>定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时， 立即执行对键的删除操作。</p></li><li><p>惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是  否过期， 如果过期的话， 就删除该键;如果没有过期， 就返回该键。</p></li><li><p>定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至  于要删除多少过期键， 以及要检查多少个数据库， 则由算法决定。</p></li></ol><h3 id="11-Redis-的回收策略（淘汰策略）"><a href="#11-Redis-的回收策略（淘汰策略）" class="headerlink" title="11. Redis 的回收策略（淘汰策略）?"></a>11. Redis 的回收策略（淘汰策略）?</h3><p><strong>volatile-lru</strong>：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl</strong>： 从已设置过期时间的数据集（ server.db[i].expires） 中挑选将要过期的数据淘汰</p><p><strong>volatile-random</strong>： 从已设置过期时间的数据集（ server.db[i].expires） 中任意选择数据淘汰</p><p><strong>allkeys-lru</strong>： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰</p><p><strong>allkeys-random</strong>： 从数据集（ server.db[i].dict） 中任意选择数据淘汰</p><p><strong>no-enviction 驱逐）</strong> ： 禁止驱逐数据</p><p>注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据， 后面的 lru. ttl 以及 random 是三种不同的淘汰策略， 再加上一种 no-enviction 永不回收的策略。</p><p>使用策略规则：</p><ol><li><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率  低， 则使用 allkeys-lru</p></li><li><p>如果数据呈现平等分布， 也就是所有的数据访问频率都相同， 则使用allkeys-random</p></li></ol><h3 id="12-为什么-edis-需要把所有数据放到内存中？"><a href="#12-为什么-edis-需要把所有数据放到内存中？" class="headerlink" title="12. 为什么 edis 需要把所有数据放到内存中？"></a>12. 为什么 edis 需要把所有数据放到内存中？</h3><p>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中， 磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天， redis 将会越来越受欢迎。如果设置了最大使用的内存， 则数据已有记录数达到内存限值后不能继续插入新值。</p><h3 id="13-Redis-的同步机制了解么？"><a href="#13-Redis-的同步机制了解么？" class="headerlink" title="13. Redis 的同步机制了解么？"></a>13. Redis 的同步机制了解么？</h3><p>答：Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave， 并同时将后续修改操作记录到内存 buffer， 待完成后将 rdb 文件全量同步到复制节点， 复制节点接受完成后将 rdb 镜像加载到内存。加载完成后， 再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="14-Pipeline-有什么好处，为什么要用pipeline？"><a href="#14-Pipeline-有什么好处，为什么要用pipeline？" class="headerlink" title="14. Pipeline 有什么好处，为什么要用pipeline？"></a>14. Pipeline 有什么好处，为什么要用pipeline？</h3><p>答：可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。</p><h3 id="15-是否使用过-Redis-集群，集群的原理是什么？"><a href="#15-是否使用过-Redis-集群，集群的原理是什么？" class="headerlink" title="15. 是否使用过 Redis 集群，集群的原理是什么？"></a>15. 是否使用过 Redis 集群，集群的原理是什么？</h3><ol><li><p>Redis Sentinal 着眼于高可用， 在 master 宕机时会自动将 slave 提升为master， 继续提供服务。</p></li><li><p>Redis Cluster 着眼于扩展性， 在单个 redis 内存不足时， 使用 Cluster 进行分片存储。</p></li></ol><h3 id="16-Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#16-Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="16. Redis 集群方案什么情况下会导致整个集群不可用？"></a>16. Redis 集群方案什么情况下会导致整个集群不可用？</h3><p>答： 有 A， B， C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了， 那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><h3 id="17-Redis-支持的Java-客户端都有哪些？官方推荐用哪个？"><a href="#17-Redis-支持的Java-客户端都有哪些？官方推荐用哪个？" class="headerlink" title="17. Redis 支持的Java 客户端都有哪些？官方推荐用哪个？"></a>17. Redis 支持的Java 客户端都有哪些？官方推荐用哪个？</h3><p>答： Redisson. Jedis. lettuce 等等， 官方推荐使用 Redisson。</p><h3 id="18-Jedis-与-Redisson-对比有什么优缺点？"><a href="#18-Jedis-与-Redisson-对比有什么优缺点？" class="headerlink" title="18. Jedis 与 Redisson 对比有什么优缺点？"></a>18. Jedis 与 Redisson 对比有什么优缺点？</h3><p>答： Jedis 是 Redis 的 Java 实现的客户端， 其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单， 不支持字符串操作， 不支持排序. 事务. 管道. 分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h3 id="19-Redis-如何设置密码及验证密码？"><a href="#19-Redis-如何设置密码及验证密码？" class="headerlink" title="19. Redis 如何设置密码及验证密码？"></a>19. Redis 如何设置密码及验证密码？</h3><p>设置密码： config set requirepass 123456 授权密码： auth 123456</p><h3 id="20-说说-Redis-哈希槽的概念？"><a href="#20-说说-Redis-哈希槽的概念？" class="headerlink" title="20. 说说 Redis 哈希槽的概念？"></a>20. 说说 Redis 哈希槽的概念？</h3><p>答： Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念， Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽， 集群的每个节点负责一部分 hash 槽。</p><h3 id="21-Redis-集群的主从复制模型是怎样的？"><a href="#21-Redis-集群的主从复制模型是怎样的？" class="headerlink" title="21. Redis 集群的主从复制模型是怎样的？"></a>21. Redis 集群的主从复制模型是怎样的？</h3><p>答： 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用， 所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.</p><h3 id="22-Redis-集群会有写操作丢失吗？为什么？"><a href="#22-Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="22. Redis 集群会有写操作丢失吗？为什么？"></a>22. Redis 集群会有写操作丢失吗？为什么？</h3><p>答：Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h3 id="23-Redis-集群之间是如何复制的？"><a href="#23-Redis-集群之间是如何复制的？" class="headerlink" title="23. Redis 集群之间是如何复制的？"></a>23. Redis 集群之间是如何复制的？</h3><p>答： 异步复制 </p><h3 id="24-Redis-集群最大节点个数是多少？"><a href="#24-Redis-集群最大节点个数是多少？" class="headerlink" title="24. Redis 集群最大节点个数是多少？"></a>24. Redis 集群最大节点个数是多少？</h3><p>答： 16384 个。</p><h3 id="25-Redis-集群如何选择数据库？"><a href="#25-Redis-集群如何选择数据库？" class="headerlink" title="25. Redis 集群如何选择数据库？"></a>25. Redis 集群如何选择数据库？</h3><p>答： Redis 集群目前无法做数据库选择， 默认在 0 数据库。</p><h3 id="26-怎么测试-Redis-的连通性？"><a href="#26-怎么测试-Redis-的连通性？" class="headerlink" title="26. 怎么测试 Redis 的连通性？"></a>26. 怎么测试 Redis 的连通性？</h3><p>答： 使用 ping 命令。</p><h3 id="27-怎么理解-Redis-事务？"><a href="#27-怎么理解-Redis-事务？" class="headerlink" title="27. 怎么理解 Redis 事务？"></a>27. 怎么理解 Redis 事务？</h3><p>答：</p><ol><li><p>事务是一个单独的隔离操作：  事务中的所有命令都会序列化. 按顺序地执行。事务在执行的过程中， 不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作： 事务中的命令要么全部被执行， 要么全部都不执行。</p></li></ol><h3 id="28-Redis-事务相关的命令有哪几个？"><a href="#28-Redis-事务相关的命令有哪几个？" class="headerlink" title="28. Redis 事务相关的命令有哪几个？"></a>28. Redis 事务相关的命令有哪几个？</h3><p>答： MULTI. EXEC. DISCARD. WATCH</p><h3 id="29-Redis-key-的过期时间和永久有效分别怎么设置？"><a href="#29-Redis-key-的过期时间和永久有效分别怎么设置？" class="headerlink" title="29. Redis key 的过期时间和永久有效分别怎么设置？"></a>29. Redis key 的过期时间和永久有效分别怎么设置？</h3><p>答： EXPIRE 和 PERSIST 命令。</p><h3 id="30-Redis-如何做内存优化？"><a href="#30-Redis-如何做内存优化？" class="headerlink" title="30. Redis 如何做内存优化？"></a>30. Redis 如何做内存优化？</h3><p>答： 尽可能使用散列表（ hashes）， 散列表（ 是说散列表里面存储的数少） 使用的内存非常小， 所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象， 不要为这个用户的名称， 姓氏， 邮箱， 密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面.</p><h3 id="31-Redis-回收进程如何工作的？"><a href="#31-Redis-回收进程如何工作的？" class="headerlink" title="31. Redis 回收进程如何工作的？"></a>31. Redis 回收进程如何工作的？</h3><p>答： 一个客户端运行了新的命令， 添加了新的数据。Redi 检查内存使用情况， 如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执行， 等等。所以我们不断地穿越内存限制的边界， 通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（ 例如很大的集合的交集保存到一个新的键）， 不用多久内存限制就会被这个内存使用量超越。</p><h3 id="32-都有哪些办法可以降低-Redis-的内存使用情况呢？"><a href="#32-都有哪些办法可以降低-Redis-的内存使用情况呢？" class="headerlink" title="32. 都有哪些办法可以降低 Redis 的内存使用情况呢？"></a>32. 都有哪些办法可以降低 Redis 的内存使用情况呢？</h3><p>答：如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据， 因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p><h3 id="33-Redis-的内存用完了会发生什么？"><a href="#33-Redis-的内存用完了会发生什么？" class="headerlink" title="33. Redis 的内存用完了会发生什么？"></a>33. Redis 的内存用完了会发生什么？</h3><p>答：如果达到设置的上限，Redis 的写命令会返回错误信息（ 但是读命令还可以正常返回。） 或者你可以将 Redis 当缓存来使用配置淘汰机制， 当 Redis 达到内存上限时会冲刷掉旧的内容。 </p><h3 id="34-一个-Redis-实例最多能存放多少的-keys？List-Set-Sorted-Set-他们最多能存放多少元素？"><a href="#34-一个-Redis-实例最多能存放多少的-keys？List-Set-Sorted-Set-他们最多能存放多少元素？" class="headerlink" title="34. 一个 Redis 实例最多能存放多少的 keys？List. Set. Sorted Set 他们最多能存放多少元素？"></a>34. 一个 Redis 实例最多能存放多少的 keys？List. Set. Sorted Set 他们最多能存放多少元素？</h3><p>答：理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list. set. 和 sorted set 都可以放 232 个元素。换句话说， Redis 的存储极限是系统中的可用内存值。 </p><h3 id="35-MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证redis-中的数据都是热点数据？"><a href="#35-MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证redis-中的数据都是热点数据？" class="headerlink" title="35. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证redis 中的数据都是热点数据？"></a>35. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证redis 中的数据都是热点数据？</h3><p>答： Redis 内存数据集大小上升到一定大小的时候， 就会施行数据淘汰策略。相关知识： Redis 提供 6 种数据淘汰策略：</p><p><strong>volatile-lru</strong>：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近最少使用的数据淘汰 </p><p><strong>volatile-ttl</strong>： 从已设置过期时间的数据集（ server.db[i].expires） 中挑选将要过期的数据淘汰 </p><p><strong>volatile-random</strong>： 从已设置过期时间的数据集（ server.db[i].expires） 中任意选择数据淘汰 </p><p><strong>allkeys-lru</strong>： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰 </p><p><strong>allkeys-random</strong>： 从数据集（ server.db[i].dict） 中任意选择数据淘汰 </p><p><strong>no-enviction（ 驱逐）</strong> ： 禁止驱逐数据 </p><h3 id="36-Redis-最适合的场景？"><a href="#36-Redis-最适合的场景？" class="headerlink" title="36. Redis 最适合的场景？"></a>36. Redis 最适合的场景？</h3><h5 id="1-会话缓存（-Session-Cache）"><a href="#1-会话缓存（-Session-Cache）" class="headerlink" title="1. 会话缓存（ Session Cache）"></a>1. 会话缓存（ Session Cache）</h5><p>最常用的一种使用 Redis 的情景是会话缓存（ session cache）。用 Redis 缓存会话比其他存储（ 如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时， 如果用户的购物车信息全部丢失， 大部分人都会不高兴的， 现在， 他们还会这样吗？ 幸运的是， 随着 Redis 这些年的改进， 很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。</p><h5 id="2-全页缓存（-FPC）"><a href="#2-全页缓存（-FPC）" class="headerlink" title="2. 全页缓存（ FPC）"></a>2. 全页缓存（ FPC）</h5><p>除基本的会话 token 之外， Redis 还提供很简便的 FPC 平台。回到一致性问题， 即使重启了 Redis 实例， 因为有磁盘的持久化， 用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外， 对 WordPress 的用户来说， Pantheon 有一个非常好的插件 wp-redis， 这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><h5 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h5><p>Reids 在内存存储引擎领域的一大优点是提供 list 和  set  操作， 这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（ 如 Python）对 list 的 push/pop 操作。 如果你快速的在 Google 中搜索“ Redis queues”， 你马上就能找到大量的开源项目， 这些项目的目的就是利用 Redis 创建非常好的后端工具， 以满足各种队列需求。例如， Celery 有一个后台就是使用 Redis 作为 broker， 你可以从这里去查看。</p><h5 id="4-排行榜-计数器"><a href="#4-排行榜-计数器" class="headerlink" title="4. 排行榜/计数器"></a>4. 排行榜/计数器</h5><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（ Set） 和有序集合（ Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以， 我们要从排序集合中获取到排名最靠前的 10 个用户– 我们称之为“ user_scores”， 我们只需要像下面一样执行即可： 当然， 这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，  你需要这样执行：  ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子， 用 Ruby 实现的， 它的排行榜就是使用 Redis 来存储数据的， 你可以在这里看到。</p><h5 id="5-发布-订阅"><a href="#5-发布-订阅" class="headerlink" title="5. 发布/订阅"></a>5. 发布/订阅</h5><p>最后（ 但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，  还可作为基于发布/订阅的脚本触发器， 甚至用 Redis 的发布/订阅功能来建立聊天系统！</p><h3 id="37-假如-Redis-里面有-1-亿个key，其中有-10w-个key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#37-假如-Redis-里面有-1-亿个key，其中有-10w-个key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="37. 假如 Redis 里面有 1 亿个key，其中有 10w 个key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>37. 假如 Redis 里面有 1 亿个key，其中有 10w 个key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>答： 使用 keys 指令可以扫出指定模式的 key 列表。 </p><p>对方接着追问： 如果这个 redis 正在给线上的业务提供服务， 那使用 keys 指令会有什么问题？</p><p>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间， 线上服务会停顿， 直到指令执行完毕， 服务才能恢复。这个时候可以使用 scan 指令， scan 指令可以无阻塞的提取出指定模式的 key 列表， 但是会有一定的重复概率， 在客户端做一次去重就可以了， 但是整体所花费的时间会比直接用 keys 指令长。 </p><h3 id="38-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#38-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="38. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>38. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h3><p>答：如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值， 使得过期时间分散一些。</p><h3 id="39-使用过-Redis-做异步队列么，你是怎么用的？"><a href="#39-使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="39. 使用过 Redis 做异步队列么，你是怎么用的？"></a>39. 使用过 Redis 做异步队列么，你是怎么用的？</h3><p>答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候， 要适当 sleep 一会再重试。</p><h5 id="如果对方追问可不可以不用-sleep-呢？"><a href="#如果对方追问可不可以不用-sleep-呢？" class="headerlink" title="如果对方追问可不可以不用 sleep 呢？"></a>如果对方追问可不可以不用 sleep 呢？</h5><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？ 使用 pub/sub 主题订阅者模式， 可以实现1:N 的消息队列。</p><h5 id="如果对方追问-pub-sub-有什么缺点？"><a href="#如果对方追问-pub-sub-有什么缺点？" class="headerlink" title="如果对方追问 pub/sub 有什么缺点？"></a>如果对方追问 pub/sub 有什么缺点？</h5><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。</p><h5 id="如果对方追问-redis-如何实现延时队列？"><a href="#如果对方追问-redis-如何实现延时队列？" class="headerlink" title="如果对方追问 redis 如何实现延时队列？"></a>如果对方追问 redis 如何实现延时队列？</h5><h5 id><a href="#" class="headerlink" title></a></h5><p>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话， 怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里， 面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指， 在椅子背后。 </p><h3 id="40-使用过-Redis-分布式锁么，它是什么回事？"><a href="#40-使用过-Redis-分布式锁么，它是什么回事？" class="headerlink" title="40. 使用过 Redis 分布式锁么，它是什么回事？"></a>40. 使用过 Redis 分布式锁么，它是什么回事？</h3><p>先拿 setnx 来争抢锁， 抢到之后， 再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错， 然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了， 那会怎么样？</p><p>这时候你要给予惊讶的反馈： 唉， 是喔， 这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋， 故作思考片刻， 好像接下来的结果是你主动思考出来的， 然后回答： 我记得 set 指令有非常复杂的参数， 这个应该是可以同时把 setnx 和expire 合成一条指令来用的！ 对方这时会显露笑容， 心里开始默念： 摁， 这小子还不错。</p><h3 id="41缓存穿透、缓存击穿和缓存雪崩"><a href="#41缓存穿透、缓存击穿和缓存雪崩" class="headerlink" title="41缓存穿透、缓存击穿和缓存雪崩"></a>41缓存穿透、缓存击穿和缓存雪崩</h3><p>缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问 Mysql。而这个过程中可能会存在很多问题：</p><h5 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h5><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。（比如黑客故意伪造⼀些乱七八糟的key）</p><p>缓存穿透常见的解决方案有两种：</p><p>1.缓存空对象：实现简单，维护方便，但会造成额外的内存消耗。</p><p>2.使⽤布隆过滤器： 它的作⽤就是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器来拦截不存在的key</p><h5 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h5><p>某⼀个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿。</p><p>缓存击穿常见的解决方案有两种：</p><p>1.互斥锁：因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行</p><p>2.逻辑过期：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，数据会一直占用内存，所以可以采用逻辑过期方案。把过期时间设置在 redis的value中，这个过期时间并不会直接作用于redis，而是通过后续逻辑去处理。</p><p>逻辑过期重构流程：假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞， 获得了锁的线程他会开启一个线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁，而线程1直接进行返回。</p><h5 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h5><p>如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问mysql了。</p><p>解决办法：就是在过期时间上增加⼀点随机值，另外如果搭建⼀个高可用的Redis集群也是防止缓存雪崩的有效手段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-面试题&quot;&gt;&lt;a href=&quot;#Redis-面试题&quot; class=&quot;headerlink&quot; title=&quot;Redis    面试题&quot;&gt;&lt;/a&gt;Redis    面试题&lt;/h2&gt;&lt;h3 id=&quot;1-什么是Redis&quot;&gt;&lt;a href=&quot;#1-什么是Redi</summary>
      
    
    
    
    <category term="Redis面试" scheme="https://kksinher.github.io/categories/Redis%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Redis" scheme="https://kksinher.github.io/tags/Redis/"/>
    
    <category term="缓存穿透" scheme="https://kksinher.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
    <category term="缓存击穿" scheme="https://kksinher.github.io/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
    <category term="缓存雪崩" scheme="https://kksinher.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://kksinher.github.io/2023/02/28/Mybatis/"/>
    <id>https://kksinher.github.io/2023/02/28/Mybatis/</id>
    <published>2023-02-28T03:41:48.000Z</published>
    <updated>2023-02-28T06:29:30.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-面试题"><a href="#MyBatis-面试题" class="headerlink" title="MyBatis    面试题"></a>MyBatis    面试题</h2><h3 id="1、什么是Mybatis？"><a href="#1、什么是Mybatis？" class="headerlink" title="1、什么是Mybatis？"></a><strong>1、什么是Mybatis？</strong></h3><ol><li><p>Mybatis 是一个半 ORM（ 对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身， 不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能， 灵活度高。 </p></li><li><p>MyBatis 可以使用 XML 或注解来配置和映射原生信息， 将  POJO 映射成数据库中的记录， 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p></li><li><p>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来， 并通过java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（ 从执行 sql 到返回 result 的过程）。</p></li></ol><h3 id="2、Mybaits-的优点："><a href="#2、Mybaits-的优点：" class="headerlink" title="2、Mybaits 的优点："></a><strong>2、Mybaits 的优点：</strong></h3><ol><li><p>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并可重用。</p></li><li><p>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</p></li><li><p>很好的与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</p></li><li><p>能够与 Spring 很好的集成；</p></li><li><p>提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。</p></li></ol><h3 id="3、MyBatis-框架的缺点："><a href="#3、MyBatis-框架的缺点：" class="headerlink" title="3、MyBatis 框架的缺点："></a>3、MyBatis 框架的缺点：</h3><ol><li><p>SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写SQL 语句的功底有一定要求。</p></li><li><p>SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。</p></li></ol><h3 id="4、MyBatis-框架适用场合："><a href="#4、MyBatis-框架适用场合：" class="headerlink" title="4、MyBatis 框架适用场合："></a>4、MyBatis 框架适用场合：</h3><ol><li><p>MyBatis 专注于 SQL 本身， 是一个足够灵活的 DAO 层解决方案。</p></li><li><p>对性能的要求很高，或者需求变化较多的项目，如互联网项目， MyBatis 将是不错的选择。</p></li></ol><h3 id="5、-和-的区别是什么？"><a href="#5、-和-的区别是什么？" class="headerlink" title="5、#{}和${}的区别是什么？"></a>5、#{}和${}的区别是什么？</h3><p>#{}是预编译处理， ${}是字符串替换。</p><p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值；</p><p>Mybatis 在处理${}时， 就是把${}替换成变量的值。使用#{}可以有效的防止 SQL 注入， 提高系统安全性。</p><h3 id="6、当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#6、当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="6、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>6、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><p>第 1 种： 通过在查询的 sql 语句中定义字段名的别名， 让字段名的别名和实体类的属性名一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”</span> <span class="attr">me.gacl.domain.order</span>”&gt;</span></span><br><span class="line">select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第 2 种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</resultMap></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">&lt;!–用 id 属性来映射主键字段–&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line">&lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性–&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7、-模糊查询like-语句该怎么写"><a href="#7、-模糊查询like-语句该怎么写" class="headerlink" title="7、 模糊查询like 语句该怎么写?"></a>7、 模糊查询like 语句该怎么写?</h3><p>第 1 种： 在 Java 代码中添加 sql 通配符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">wildcardname</span> <span class="operator">=</span> “%smi%”;</span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">select * from foo where bar like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第 2 种： 在 sql 语句中拼接通配符， 会引起 sql 注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list<span class="tag">&lt;<span class="name">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectlike”</span>&gt;</span></span><br><span class="line">select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8、通常一个Xml-映射文件，都会写一个Dao-接口与之对应，-请问，这个Dao-接口的工作原理是什么？Dao-接口里的方法，-参数不同时，方法能重载吗？"><a href="#8、通常一个Xml-映射文件，都会写一个Dao-接口与之对应，-请问，这个Dao-接口的工作原理是什么？Dao-接口里的方法，-参数不同时，方法能重载吗？" class="headerlink" title="8、通常一个Xml 映射文件，都会写一个Dao 接口与之对应， 请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法， 参数不同时，方法能重载吗？"></a>8、通常一个Xml 映射文件，都会写一个Dao 接口与之对应， 请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法， 参数不同时，方法能重载吗？</h3><p>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值； 接口的方法名， 就是映射文件中 Mapper 的 Statement 的 id 值； 接口方法内的参数， 就是传递给 sql 的参数。</p><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值， 可唯一定位一个 MapperStatement。在 Mybatis 中， 每一个<select>、<insert>、<update>、<delete>标签， 都会被解析为一个MapperStatement 对象。</delete></update></insert></select></p><p>举例： com.mybatis3.mappers.StudentDao.findStudentById， 可以唯一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为findStudentById 的 MapperStatement 。</p><p>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理， Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy， 代理对象会拦截接口方法， 转而执行 MapperStatement 所代表的 sql， 然后将 sql 执行结果返回。</p><h3 id="9、Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#9、Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="9、Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>9、Mybatis 是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis 使用 RowBounds 对象进行分页， 它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能， 也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 Mybatis 提供的插件接口， 实现自定义插件， 在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="10、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#10、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="10、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>10、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用<resultMap>标签， 逐一定义数据库列名和对象属性名之间的映射关系。</resultMap></p><p>第二种是使用 sql 列的别名功能， 将列的别名书写为对象属性名。</p><p>有了列名与属性名的映射关系后， Mybatis 通过反射创建对象， 同时使用反射给对象的属性逐一赋值并返回， 那些找不到映射关系的属性， 是无法完成赋值的。</p><h3 id="11、如何执行批量插入"><a href="#11、如何执行批量插入" class="headerlink" title="11、如何执行批量插入?"></a>11、如何执行批量插入?</h3><p>首先,创建一个简单的 insert 语句:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span>&gt;</span></span><br><span class="line">insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 java 代码中像下面这样执行批处理插入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list &lt; string &gt; names = <span class="keyword">new</span> <span class="title class_">arraylist</span>(); names.add(“fred”); names.add(“barney”); names.add(“betty”);</span><br><span class="line">names.add(“wilma”);</span><br><span class="line"><span class="comment">// 注意这里 executortype.batch sqlsession sqlsession =</span></span><br><span class="line">sqlsessionfactory.opensession(executortype.batch); <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">namemapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlsession.getmapper(namemapper.class); <span class="keyword">for</span> (string name: names) &#123;</span><br><span class="line">mapper.insertname(name);</span><br><span class="line">&#125;</span><br><span class="line">sqlsession.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace(); sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">sqlsession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、如何获取自动生成的-主-键值"><a href="#12、如何获取自动生成的-主-键值" class="headerlink" title="12、如何获取自动生成的(主)键值?"></a>12、如何获取自动生成的(主)键值?</h3><p>insert 方法总是返回一个 int 值 ， 这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=”insertname” usegeneratedkeys=”<span class="literal">true</span>” keyproperty=” id”&gt;</span><br><span class="line">insert into <span class="title function_">names</span> <span class="params">(name)</span> values (#&#123;name&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"><span class="type">name</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">name</span>(); name.setname(“fred”);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> mapper.insertname(name);</span><br><span class="line"><span class="comment">// 完成后,id 已经被设置到对象中system.out.println(“rows inserted = ” + rows);</span></span><br><span class="line">system.out.println(“generated <span class="type">key</span> <span class="variable">value</span> <span class="operator">=</span> ” + name.getid());</span><br></pre></td></tr></table></figure><h3 id="13、在-mapper-中如何传递多个参数"><a href="#13、在-mapper-中如何传递多个参数" class="headerlink" title="13、在 mapper 中如何传递多个参数?"></a>13、在 mapper 中如何传递多个参数?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UserselectUser</span><span class="params">(String name,String area)</span>;</span><br><span class="line">对应的 xml,#&#123;<span class="number">0</span>&#125;代表接收的是 dao 层中的第一个参数，#&#123;<span class="number">1</span>&#125;代表 dao 层中第二参数，更多参数一致往后加即可。</span><br></pre></td></tr></table></figure><ol><li>第一种： DAO 层的函数</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span><span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span> select *fromuser_user_t·、whereuser_name = #&#123;0&#125;</span><br><span class="line">anduser_area=#&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>第二种： 使用 <a href="https://www.yuque.com/yevxum/bd3ufw/ytt7gf/pdf?toc=false&key=exports:docx:doc:2456644:1566790188000&x-yuque-fc-token=xa-KwZfJsLj7JPG0Z6MoLA==%7C5dmVbAUI-5hvwkn6L5Vz1aqe2KWsJfck6E1Tg2cTaZM=">@param</a> 注解:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">usermapper</span> &#123;</span><br><span class="line">user <span class="title function_">selectuser</span><span class="params">(<span class="meta">@param(“username”)</span> string username,<span class="meta">@param(“hashedpassword”)</span> string hashedpassword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给mapper):</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectuser”</span> <span class="attr">resulttype</span>=<span class="string">”user”</span>&gt;</span> select id, username, hashedpassword from some_table</span><br><span class="line">where username = #&#123;username&#125;</span><br><span class="line">and hashedpassword = #&#123;hashedpassword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>第三种： 多个参数封装成 map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的</span></span><br><span class="line">SQL</span><br><span class="line"><span class="comment">//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此我们使用 Map 集合来装载我们的参数</span></span><br><span class="line">Map &lt; String, Object &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(); map.put(<span class="string">&quot;start&quot;</span>, start);</span><br><span class="line">map.put(<span class="string">&quot;end&quot;</span>, end);</span><br><span class="line"><span class="keyword">return</span> sqlSession.selectList(<span class="string">&quot;StudentID.pagination&quot;</span>, map);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">MybatisUtil.closeSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、Mybatis动态sql-有什么用？执行原理？有哪些动态sql？"><a href="#14、Mybatis动态sql-有什么用？执行原理？有哪些动态sql？" class="headerlink" title="14、Mybatis动态sql 有什么用？执行原理？有哪些动态sql？"></a>14、Mybatis动态sql 有什么用？执行原理？有哪些动态sql？</h3><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p><p>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose</p><h4 id="when-otherwise-bind-。"><a href="#when-otherwise-bind-。" class="headerlink" title="| when | otherwise | bind 。"></a>| when | otherwise | bind 。</h4><h3 id="15、Xml映射文件中，除了常见的select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#15、Xml映射文件中，除了常见的select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="15、Xml映射文件中，除了常见的select|insert|updae|delete 标签之外，还有哪些标签？"></a>15、Xml映射文件中，除了常见的select|insert|updae|delete 标签之外，还有哪些标签？</h3><p>答： <resultMap>、<parameterMap>、<sql>、<include>、</include></sql></parameterMap></resultMap></p><p><selectKey>， 加上动态 sql 的 9 个标签， 其中<sql>为 sql 片段标签， 通过</sql></selectKey></p><p><include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。</selectKey></include></p><h3 id="16、Mybatis-的-Xml-映射文件中，-不同的-Xml-映射文件，-id-是否可以重复？"><a href="#16、Mybatis-的-Xml-映射文件中，-不同的-Xml-映射文件，-id-是否可以重复？" class="headerlink" title="16、Mybatis 的 Xml 映射文件中， 不同的 Xml 映射文件， id 是否可以重复？"></a>16、Mybatis 的 Xml 映射文件中， 不同的 Xml 映射文件， id 是否可以重复？</h3><p>不同的 Xml 映射文件， 如果配置了 namespace， 那么 id 可以重复； 如果没有配置 namespace， 那么 id 不能重复；</p><p>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key 使用的， 如果没有 namespace， 就剩下 id， 那么， id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p><h3 id="17、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#17、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="17、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>17、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate 属于全自动 ORM 映射工具， 使用 Hibernate 查询关联对象或者关联集合对象时， 可以根据对象关系模型直接获取， 所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><h3 id="18、-一对一、一对多的关联查询-？"><a href="#18、-一对一、一对多的关联查询-？" class="headerlink" title="18、 一对一、一对多的关联查询 ？"></a>18、 一对一、一对多的关联查询 ？</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lcb.mapping.userMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--association一对一关联查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--collection一对多关联查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--collection一对多关联查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getClass2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line">select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.lcb.user.Classes&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ClassesResultMap2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;c_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lcb.user.Teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;student&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.lcb.user.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="19、MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#19、MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="19、MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>19、MyBatis 实现一对一有几种方式?具体怎么操作的？</h3><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；</p><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p><h3 id="20、MyBatis-实现一对多有几种方式-怎么操作的？"><a href="#20、MyBatis-实现一对多有几种方式-怎么操作的？" class="headerlink" title="20、MyBatis 实现一对多有几种方式,怎么操作的？"></a>20、MyBatis 实现一对多有几种方式,怎么操作的？</h3><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap 里面的 collection 节点配置一对多的类就可以完成； 嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</p><h3 id="21、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#21、Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="21、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>21、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>答： Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载， association 指的就是一对一， collection 指的就是一对多查询。在 Mybatis 配置文件中， 可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p><p>它的原理是， 使用 CGLIB 创建目标对象的代理对象， 当调用目标方法时， 进入拦截器方法， 比如调用 a.getB().getName()， 拦截器 invoke()方法发现 a.getB()是null 值， 那么就会单独发送事先保存好的查询关联 B 对象的 sql， 把 B 查询上来， 然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了， 不光是 Mybatis， 几乎所有的包括 Hibernate， 支持延迟加载的原理都是一样的。</p><h3 id="22、Mybatis-的一级、二级缓存"><a href="#22、Mybatis-的一级、二级缓存" class="headerlink" title="22、Mybatis 的一级、二级缓存:"></a>22、Mybatis 的一级、二级缓存:</h3><ol><li><p> 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为Session， 当 Session flush 或  close 之后， 该  Session 中的所有  Cache 就将清空， 默认打开一级缓存。</p></li><li><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置</p><p><cache> ；</cache></p></li><li><p>对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 。</p></li></ol><h3 id="23、什么是-MyBatis-的接口绑定？有哪些实现方式？"><a href="#23、什么是-MyBatis-的接口绑定？有哪些实现方式？" class="headerlink" title="23、什么是 MyBatis 的接口绑定？有哪些实现方式？"></a>23、什么是 MyBatis 的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式,一种是通过注解绑定， 就是在接口的方法上面加上@Select、@Update 等注解， 里面包含 Sql 语句来绑定； 另外一种就是通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</p><h3 id="24、使用-MyBatis-的mapper-接口调用时有哪些要求？"><a href="#24、使用-MyBatis-的mapper-接口调用时有哪些要求？" class="headerlink" title="24、使用 MyBatis 的mapper 接口调用时有哪些要求？"></a>24、使用 MyBatis 的mapper 接口调用时有哪些要求？</h3><ol><li><p>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；</p></li><li><p>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的parameterType 的类型相同；</p></li><li><p>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的resultType 的类型相同；</p></li><li><p>Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</p></li></ol><h3 id="25、Mapper-编写有哪几种方式？"><a href="#25、Mapper-编写有哪几种方式？" class="headerlink" title="25、Mapper 编写有哪几种方式？"></a>25、Mapper 编写有哪几种方式？</h3><p>第一种： 接口实现类继承 SqlSessionDaoSupport： 使用此种方法需要编写mapper 接口， mapper 接口实现类、mapper.xml 文件。</p><ol><li>在 sqlMapConfig.xml 中配置 mapper.xml 的位置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>定义 mapper 接口</p></li><li><p>实现类集成 SqlSessionDaoSupport</p></li></ol><p>​    mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p><ol start="4"><li>spring 配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span><span class="attr">value</span>=<span class="string">&quot;mapper 接口地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种： 使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><ol><li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置， 如果 mapper.xml 和mappre 接口的名称相同且在同一个目录， 这里可以不用配置</p></li><li><p>定义 mapper 接口： </p><ol><li>mapper.xml 中的 namespace 为 mapper 接口的地址</li><li>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</li></ol></li></ol><p>3、Spring 中定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span><span class="attr">value</span>=<span class="string">&quot;mapper 接口地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>第三种： 使用 mapper 扫描器：</p><p>1、mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； 如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml 中进行配置。</p><p>2、定义 mapper 接口： </p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致， 且放在同一个目录</p><p>3、配置 mapper 扫描器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper 接口包地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p><h3 id="26、简述-Mybatis-的插件运行原理，以及如何编写一个插件。"><a href="#26、简述-Mybatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="26、简述 Mybatis 的插件运行原理，以及如何编写一个插件。"></a>26、简述 Mybatis 的插件运行原理，以及如何编写一个插件。</h3><p>答： Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、</p><p>StatementHandler、Executor 这 4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法， 当然， 只会拦截那些你指定需要拦截的方法。</p><p>编写插件： 实现 Mybatis 的 Interceptor 接口并复写 intercept()方法， 然后在给插件编写注解， 指定要拦截哪一个接口的哪些方法即可， 记住， 别忘了在配置文件中配置你编写的插件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatis-面试题&quot;&gt;&lt;a href=&quot;#MyBatis-面试题&quot; class=&quot;headerlink&quot; title=&quot;MyBatis    面试题&quot;&gt;&lt;/a&gt;MyBatis    面试题&lt;/h2&gt;&lt;h3 id=&quot;1、什么是Mybatis？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Mybatis 面试" scheme="https://kksinher.github.io/categories/Mybatis-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Mybatis" scheme="https://kksinher.github.io/tags/Mybatis/"/>
    
    <category term="ORM" scheme="https://kksinher.github.io/tags/ORM/"/>
    
    <category term="Mapper" scheme="https://kksinher.github.io/tags/Mapper/"/>
    
  </entry>
  
  <entry>
    <title>Http&amp;Servlet&amp;Tomcat</title>
    <link href="https://kksinher.github.io/2023/02/27/Http-Servlet-Tomcat/"/>
    <id>https://kksinher.github.io/2023/02/27/Http-Servlet-Tomcat/</id>
    <published>2023-02-27T12:51:40.000Z</published>
    <updated>2023-02-27T15:27:36.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><p><strong>概念</strong>：HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p><h4 id="HTTP-协议特点："><a href="#HTTP-协议特点：" class="headerlink" title="HTTP 协议特点："></a>HTTP 协议特点：</h4><ol><li><p>基于TCP协议：面向连接，安全</p></li><li><p>基于请求-响应模型的：一次请求对应一次响应</p></li><li><p>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。</p></li></ol><p>缺点：多次请求间不能共享数据。</p><p>优点：速度快</p><h4 id="请求数据分为3部分："><a href="#请求数据分为3部分：" class="headerlink" title="请求数据分为3部分："></a><strong>请求数据分为3部分：</strong></h4><ol><li><p>请求行：请求数据的第一行。其中GET表示请求方式，/表示请求资源路径，HTTP/1.1表示协议版本</p></li><li><p>请求头：第二行开始，格式为key：value形式。</p></li><li><p>请求体： POST请求的最后一部分，存放请求参数</p></li></ol><h4 id="常见的HTTP-请求头："><a href="#常见的HTTP-请求头：" class="headerlink" title="常见的HTTP 请求头："></a>常见的HTTP 请求头：</h4><p>Host: 表示请求的主机名</p><p>User-Agent: 浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 … Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT …) like Gecko；Accept：表示浏览器能接收的资源类型，如text/*，image/<em>或者</em>/*表示所有；Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</p><p>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</p><h3 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h3><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p><h3 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h3><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr><tr><td>511</td><td><strong><code>Network Authentication Required</code></strong></td><td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td></tr></tbody></table><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p><strong>概念</strong>： Tomcat是Apache 软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。</p><p>JavaEE：Java Enterprise Edition，Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAFTomcat 也被称为 Web容器、Servlet容器。<strong>Servlet 需要依赖于 Tomcat才能运行</strong></p><p>官网：<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p><ol><li><p>Web 服务器作用？ 封装HTTP协议操作，简化开发 可以将web项目部署到服务器中，对外提供网上浏览服务</p></li><li><p>Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器</p></li></ol><h4 id="Tomcat基本使用："><a href="#Tomcat基本使用：" class="headerlink" title="Tomcat基本使用："></a>Tomcat基本使用：</h4><p>下载：官网下载</p><p>安装：绿色版，直接解压即可卸载：直接删除目录即可</p><p>启动：双击：bin\startup.bat</p><p>控制台中文乱码：修改conf/ logging.properties</p><p>关闭：</p><p>直接×掉运行窗口：强制关闭</p><p>bin\shutdown.bat：正常关闭</p><p>Ctrl+C：正常关闭</p><p>配置</p><p>配置：修改启动端口号：conf/server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connecct</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">prtocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注：HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号</p><p>启动时可能出现的问题：</p><ol><li><p>端口号冲突：找到对应程序，将其关闭掉</p></li><li><p>启动窗口一闪而过：检查JAVA_HOME环境变量是否正确配置</p></li></ol><h4 id="Tomcat-部署项目"><a href="#Tomcat-部署项目" class="headerlink" title="Tomcat - 部署项目"></a>Tomcat - 部署项目</h4><p>Tomcat 部署项目：将项目放置到 webapps 目录下， 即部署完成</p><p>一般 JavaWeb项目会被打成war包，然后将 war包放到 webapps目录下，Tomcat会自动解压缩 war文件</p><h4 id="IDEA中创建Maven-Web项目"><a href="#IDEA中创建Maven-Web项目" class="headerlink" title="IDEA中创建Maven Web项目"></a>IDEA中创建Maven Web项目</h4><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227215401258.png" alt="image-20230227215401258"></p><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227215416661.png" alt="image-20230227215416661"></p><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227215445254.png" alt="image-20230227215445254"></p><h4 id="IDEA中使用-Tomcat-集成本地-Tomcat"><a href="#IDEA中使用-Tomcat-集成本地-Tomcat" class="headerlink" title="IDEA中使用  Tomcat  - 集成本地  Tomcat"></a>IDEA中使用  Tomcat  - 集成本地  Tomcat</h4><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227215513580.png" alt="image-20230227215513580"></p><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227215525105.png" alt="image-20230227215525105"></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 是 Java提供的一门动态web资源开发技术，JavaEE 规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227223944204.png" alt="image-20230227223944204"></p><h3 id="Servlet-快速入门"><a href="#Servlet-快速入门" class="headerlink" title="Servlet 快速入门"></a>Servlet 快速入门</h3><ol><li> 创建 web项目，导入 Servlet依赖坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 创建：定义一个类，实现 Servlet接口，并重写接口中所有方法，并在 service方法中输入一句话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li> 配置：在类上使用@WebServlet 注解，配置该 Servlet的访问路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br></pre></td></tr></table></figure><ol start="4"><li> 访问：启动 Tomcat，浏览器输入URL 访问该Servlet</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure><ol><li><p>Servlet 由谁创建？Servlet方法由谁调用？</p><p>Servlet由web服务器创建，Servlet方法由web服务器调用。</p></li><li><p>服务器怎么知道Servlet中一定有service方法？</p><p>因为我们自定义的Servlet，必须实现Servlet接口并复写其方法，而Servlet接口中有service方法</p></li></ol><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227224401030.png" alt="image-20230227224401030"></p><p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</li><li>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ol><h3 id="Servlet-方法介绍"><a href="#Servlet-方法介绍" class="headerlink" title="Servlet 方法介绍"></a>Servlet 方法介绍</h3><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227224718649.png" alt="image-20230227224718649"></p><h3 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h3><p><img src="/2023/02/27/Http-Servlet-Tomcat/image-20230227224736151.png" alt="image-20230227224736151"></p><h3 id="HttpServlet-原理"><a href="#HttpServlet-原理" class="headerlink" title="HttpServlet 原理"></a>HttpServlet 原理</h3><p>HTTP 协议中，GET 和 POST 请求方式的数据格式不一样，将来要想在Servlet中处理请求参数，得在service方法中判断请求方式，并且根据请求方式的不同，分别进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">mrthod</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"><span class="comment">//判断请求参数，不同请求方式，进行不一样的逻辑处理</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equlas(method))&#123;</span><br><span class="line"><span class="comment">//执行GET请求方式的处理逻辑</span></span><br><span class="line">doGet(rep,resp);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equlas(method))&#123;</span><br><span class="line"><span class="comment">//执行POST请求方式的处理逻辑</span></span><br><span class="line">doPost(req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>HttpServlet 使用步骤</p><ol><li><p>继承HttpServlet</p></li><li><p>重写doGet和doPost方法</p></li></ol></li><li><p>HttpServlet原理</p><p>   获取请求方式，并根据不同的请求方式，调用不同的doXxx方法</p></li></ol><h3 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h3><p>Servlet要想被访问，必须配置其访问路径（urlPattern）</p><ol><li><p>一个Servlet，可以配置多个 urlParttern</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&#123;&quot;/demo1&quot;,&quot;/demo2&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>urlParttern 配置规则</p><ol><li><p>精确匹配</p><p>配置路径：@WebServlet(“/user/select”)  </p><p>访问路径：localhost:8080/web-demo/user/select</p></li><li><p>目录匹配</p><p>配置路径：@WebServlet(“/user/*”)  </p><p>访问路径：localhost:8080/web-demo/user/aaa</p><p>​                    localhost:8080/web-demo/user/bbb</p></li><li><p>扩展名匹配</p><p>配置路径：@WebServlet(“*.do”)  </p><p>访问路径：localhost:8080/web-demo/aaa.do</p><p>​                    localhost:8080/web-demo/bbb.do</p></li><li><p>任意匹配</p><p>配置路径：@WebServlet(“/“)   </p><p>​                   @WebServlet(“/*”)  </p><p>访问路径：localhost:8080/web-demo/haha</p><p>​                    localhost:8080/web-demo/hehe</p></li></ol></li></ol><p>/ 和 /* 区别：</p><ol><li>当我们的项目中的Servlet配置了“/”，会覆盖掉tomcat中的DefaultServlet，当其他的 url-pattern都匹配不上时都会走这个Servlet</li><li>当我们的项目中配置了“/*”，意味着匹配任意访问路径</li></ol><p>优先级：       精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; /* &gt; /</p><h3 id="XML-配置方式编写-Servlet"><a href="#XML-配置方式编写-Servlet" class="headerlink" title="XML 配置方式编写 Servlet"></a>XML 配置方式编写 Servlet</h3><p>Servlet 从3.0版本后开始支持使用注解配置，3.0版本前只支持 XML 配置文件的配置方式</p><p>步骤：</p><ol><li>编写 Servlet类</li><li>在 web.xml中配置该Servlet</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo5<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kk.web.servlet.Demo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Http&quot;&gt;&lt;a href=&quot;#Http&quot; class=&quot;headerlink&quot; title=&quot;Http&quot;&gt;&lt;/a&gt;Http&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：HyperText Transfer Protocol，超文本传输协议，规定了浏览器</summary>
      
    
    
    
    <category term="Http&amp;Servlet&amp;Tomcat" scheme="https://kksinher.github.io/categories/Http-Servlet-Tomcat/"/>
    
    
    <category term="Servlet" scheme="https://kksinher.github.io/tags/Servlet/"/>
    
    <category term="Ioctomcat" scheme="https://kksinher.github.io/tags/Ioctomcat/"/>
    
    <category term="Http" scheme="https://kksinher.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://kksinher.github.io/2022/12/30/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://kksinher.github.io/2022/12/30/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2022-12-30T05:15:59.000Z</published>
    <updated>2022-12-30T10:39:00.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端开发（Webpack）"><a href="#前端开发（Webpack）" class="headerlink" title="前端开发（Webpack）"></a>前端开发（Webpack）</h3><h4 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h4><p>在企业级的前端项目开发中，把前端开发所需要的工具，技术，流程，经验等进行规范化，标准化</p><p>模块化：js的模块化，css的模块化，资源的模块化</p><p>组件化：复用现有的UI结构，样式，行为</p><p>规范化：目录结构的划分，编码规范化，接口规范化，文档规范化，Git分支模块管理</p><p>自动化：自动化构建，自动部署，自动化测试</p><p>企业中的Vue项目和React才能够木，都是基于工程化的方式进行开发的</p><h4 id="Webpack的基本使用"><a href="#Webpack的基本使用" class="headerlink" title="Webpack的基本使用"></a>Webpack的基本使用</h4><p><strong>概念</strong>：webpack是<strong>前端项目工程化的具体解决方案</strong></p><p><strong>主要功能</strong>：它提供了友好的<strong>前端模块开发</strong>支持，以及<strong>代码压缩混淆</strong>，<strong>处理浏览器JavaScript的兼容性</strong>，<strong>性能优化</strong></p><p>等强大的功能。</p><p>优点：提高了前端开发效率和项目的可维护性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端开发（Webpack）&quot;&gt;&lt;a href=&quot;#前端开发（Webpack）&quot; class=&quot;headerlink&quot; title=&quot;前端开发（Webpack）&quot;&gt;&lt;/a&gt;前端开发（Webpack）&lt;/h3&gt;&lt;h4 id=&quot;什么是前端工程化？&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="vue" scheme="https://kksinher.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Learn(四)</title>
    <link href="https://kksinher.github.io/2022/11/22/Spring-Learn4/"/>
    <id>https://kksinher.github.io/2022/11/22/Spring-Learn4/</id>
    <published>2022-11-22T13:03:35.000Z</published>
    <updated>2023-02-27T15:30:51.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h3><h4 id="1、AOP-基本概念"><a href="#1、AOP-基本概念" class="headerlink" title="1、AOP 基本概念"></a>1、AOP 基本概念</h4><p> （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行<strong>隔离</strong>，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p> （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p><p> （3）使用登录例子说明 AOP</p><p><img src="https://img-blog.csdnimg.cn/20200702135106266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5NjE5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2、AOP（底层原理）"><a href="#2、AOP（底层原理）" class="headerlink" title="2、AOP（底层原理）"></a>2、AOP（底层原理）</h4><p>AOP 底层使用动态代理 ，动态代理有两种情况：</p><h5 id="第一种-有接口情况"><a href="#第一种-有接口情况" class="headerlink" title="第一种 有接口情况"></a>第一种 有接口情况</h5><p>使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法</p><p><img src="https://img-blog.csdnimg.cn/20200702135134128.png?%E2%80%A63dlaXhpbl80NTQ5NjE5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="第二种-没有接口情况"><a href="#第二种-没有接口情况" class="headerlink" title="第二种 没有接口情况"></a>第二种 没有接口情况</h5><p>使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法</p><p><img src="https://img-blog.csdnimg.cn/2020070213514980.png?x%E2%80%A63dlaXhpbl80NTQ5NjE5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3、AOP（JDK-动态代理）"><a href="#3、AOP（JDK-动态代理）" class="headerlink" title="3、AOP（JDK 动态代理）"></a>3、AOP（JDK 动态代理）</h4><h5 id="（1）使用-JDK-动态代理，使用-Proxy-类里面的方法创建代理对象"><a href="#（1）使用-JDK-动态代理，使用-Proxy-类里面的方法创建代理对象" class="headerlink" title="（1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象"></a>（1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</h5><p>调用 newProxyInstance 方法，方法有三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 第一参数，类加载器</p><p> 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p><p> 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p><h5 id="（2）编写-JDK-动态代理代码"><a href="#（2）编写-JDK-动态代理代码" class="headerlink" title="（2）编写 JDK 动态代理代码"></a>（2）编写 JDK 动态代理代码</h5><p>​        1.创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        2.创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> id;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        3.使用 Proxy 类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line"> Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"> <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); </span><br><span class="line"><span class="comment">/** 第一参数，类加载器 </span></span><br><span class="line"><span class="comment">第二参数，增强方法所在的类，这个类实现的接口，(支持多个接口)</span></span><br><span class="line"><span class="comment">第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分  */</span></span><br><span class="line"> <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span>(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"> <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line"> <span class="comment">//有参数构造传递</span></span><br><span class="line"> <span class="keyword">private</span> Object obj;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.obj = obj;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//增强的逻辑</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//方法之前</span></span><br><span class="line"> System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line"> <span class="comment">//被增强的方法执行</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"> <span class="comment">//方法之后</span></span><br><span class="line"> System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AOP（术语）"><a href="#4、AOP（术语）" class="headerlink" title="4、AOP（术语）"></a>4、AOP（术语）</h4><p> <strong>连接点</strong>：类里面哪些方法可以被增强，这些方法称为连接点</p><p><strong>切入点</strong>：实际被真正增强的方法称为切入点</p><p><strong>通知（增强</strong>）：实际增强的逻辑部分称为通知，且分为以下五种类型：</p><p> （1）前置通知 （2）后置通知 （3）环绕通知 （4）异常通知 （5）最终通知</p><p><strong>切面</strong>：把通知应用到切入点过程</p><h4 id="5、AOP操作"><a href="#5、AOP操作" class="headerlink" title="5、AOP操作"></a>5、AOP操作</h4><p><strong>Spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</strong></p><h5 id="基于-AspectJ-实现-AOP-操作："><a href="#基于-AspectJ-实现-AOP-操作：" class="headerlink" title="基于 AspectJ 实现 AOP 操作："></a>基于 AspectJ 实现 AOP 操作：</h5><p>（1）基于 xml 配置文件实现 （2）基于注解方式实现（使用）</p><p> 引入相关jar包</p><p>切入点表达式，如下：</p><p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强<br>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a> )<br>（3）例子如下：<br>    例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强<br>        execution(* com.atguigu.dao.BookDao.add(..))<br>     例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强<br>        execution(* com.atguigu.dao.BookDao.* (..))<br>    例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强<br>        execution(* com.atguigu.dao.<em>.</em> (..))</p><h4 id="6、AOP-操作（AspectJ-注解）"><a href="#6、AOP-操作（AspectJ-注解）" class="headerlink" title="6、AOP 操作（AspectJ 注解）"></a>6、AOP 操作（AspectJ 注解）</h4><h5 id="（1）创建类，在类里面定义方法"><a href="#（1）创建类，在类里面定义方法" class="headerlink" title="（1）创建类，在类里面定义方法"></a>（1）创建类，在类里面定义方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）创建增强类（编写增强逻辑）"><a href="#（2）创建增强类（编写增强逻辑）" class="headerlink" title="（2）创建增强类（编写增强逻辑）"></a>（2）创建增强类（编写增强逻辑）</h5><p>在增强类里面，创建方法，让不同方法代表不同通知类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;<span class="comment">//前置通知</span></span><br><span class="line"> System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）进行通知的配置"><a href="#（3）进行通知的配置" class="headerlink" title="（3）进行通知的配置"></a>（3）进行通知的配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）配置不同类型的通知"><a href="#（4）配置不同类型的通知" class="headerlink" title="（4）配置不同类型的通知"></a>（4）配置不同类型的通知</h5><p><strong>AOP通知</strong>描述了<strong>抽取的共性功能，提供共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</strong></p><h6 id="AOP通知共分为5种类型"><a href="#AOP通知共分为5种类型" class="headerlink" title="AOP通知共分为5种类型"></a>AOP通知共分为5种类型</h6><p>前置通知，后置通知，环绕通知(重点)，返回后通知(了解)，抛出异常通知(了解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">      <span class="comment">//相同切入点抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//作用:设置当前通知方法与切入点的关系，当前通知方法在原始切入点方法前运行</span></span><br><span class="line">    <span class="comment">//value(默认)：  切入点方法名，格式为类名.方法名()</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointdemo()&quot;)</span><span class="comment">//相同切入点抽取使用！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知（返回通知）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终通知（后置通知）</span></span><br><span class="line">    <span class="comment">//作用：设置当前方法和切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</span></span><br><span class="line">    <span class="comment">//value(默认)：  切入点方法名，格式为类名.方法名()</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//环绕通知（重点，常用）</span></span><br><span class="line">    <span class="comment">//设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">@Around注意事项</span></span><br><span class="line"><span class="comment">1.环绕通知必须围绕形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</span></span><br><span class="line"><span class="comment">2.通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行（隔离）</span></span><br><span class="line"><span class="comment">3.对原始方法的调用可以不接收返回值。通知方法设置成void即可，如果接收返回值，必须设定为Object类型</span></span><br><span class="line"><span class="comment">4.原始方法的返回值如果是void类型，通知方法的返回值可以设置成void，也可以设置成Object</span></span><br><span class="line"><span class="comment">5.由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出Throwable对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、有多个增强类对同一个方法进行增强，设置增强类优先级"><a href="#7、有多个增强类对同一个方法进行增强，设置增强类优先级" class="headerlink" title="7、有多个增强类对同一个方法进行增强，设置增强类优先级"></a>7、有多个增强类对同一个方法进行增强，设置增强类优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在增强类上面添加注解 <span class="meta">@Order(数字类型值)</span>，数字类型值越小优先级越高</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>8、AOP 操作（AspectJ 配置文件）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、创建两个类，增强类和被增强类，创建方法（同上一样）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在 spring 配置文件中创建两个类对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3、在 spring 配置文件中配置切入点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-AOP&quot;&gt;&lt;a href=&quot;#Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring-AOP&quot;&gt;&lt;/a&gt;Spring-AOP&lt;/h3&gt;&lt;h4 id=&quot;1、AOP-基本概念&quot;&gt;&lt;a href=&quot;#1、AOP-基本概念&quot;</summary>
      
    
    
    
    <category term="Spring" scheme="https://kksinher.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://kksinher.github.io/tags/Spring/"/>
    
    <category term="AoP" scheme="https://kksinher.github.io/tags/AoP/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Learn(三)</title>
    <link href="https://kksinher.github.io/2022/11/07/Spring-Learn3/"/>
    <id>https://kksinher.github.io/2022/11/07/Spring-Learn3/</id>
    <published>2022-11-07T11:15:23.000Z</published>
    <updated>2023-02-27T15:30:42.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IOC-操作-Bean-管理-基于注解方式"><a href="#IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="IOC 操作 Bean 管理(基于注解方式)"></a>IOC 操作 Bean 管理(基于注解方式)</h4><h5 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h5><p> （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)</p><p> （2）使用注解，注解作用在类上面，方法上面，属性上面</p><p> （3）使用注解目的：简化 xml 配置</p><h5 id="2、Spring-针对-Bean-管理中创建对象提供注解"><a href="#2、Spring-针对-Bean-管理中创建对象提供注解" class="headerlink" title="2、Spring 针对 Bean 管理中创建对象提供注解"></a>2、Spring 针对 Bean 管理中创建对象提供注解</h5><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p><p> （1）@Component</p><p> （2）@Service</p><p> （3）@Controller</p><p> （4）@Repository</p><h5 id="3、基于注解方式实现对象创建"><a href="#3、基于注解方式实现对象创建" class="headerlink" title="3、基于注解方式实现对象创建"></a>3、基于注解方式实现对象创建</h5><h6 id="第一步-引入依赖-（引入spring-aop-jar包）"><a href="#第一步-引入依赖-（引入spring-aop-jar包）" class="headerlink" title="第一步 引入依赖 （引入spring-aop jar包）"></a>第一步 引入依赖 （引入spring-aop jar包）</h6><h6 id="第二步-开启组件扫描"><a href="#第二步-开启组件扫描" class="headerlink" title="第二步 开启组件扫描"></a>第二步 开启组件扫描</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描 1.如果扫描多个包，多个包使用逗号隔开;2.扫描包上层目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="第三步-创建类，在类上面添加创建对象注解"><a href="#第三步-创建类，在类上面添加创建对象注解" class="headerlink" title="第三步 创建类，在类上面添加创建对象注解"></a>第三步 创建类，在类上面添加创建对象注解</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面 value 属性值可以省略不写（这个类只有一个bean）</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span> </span><br><span class="line"><span class="comment">//注解等同于XML配置文件:&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span><span class="comment">//控制生成单个或多个对象 &quot;singleton &quot;或&quot;prototype&quot; 默认singleton </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring提供@Component 注解的三个衍生注解：</p><p>@Controller:用于表现层bean的定义</p><p>@Service:用于业务层bean的定义</p><p>@Repository:用于数据层bean的定义</p><h5 id="4、开启组件扫描细节配置"><a href="#4、开启组件扫描细节配置" class="headerlink" title="4、开启组件扫描细节配置"></a>4、开启组件扫描细节配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment"> use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment"> context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-defaultfilters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="comment">&lt;!--代表只扫描Controller注解的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment"> 下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment"> context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="comment">&lt;!--表示Controller注解的类之外一切都进行扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5、完全注解开发"><a href="#5、完全注解开发" class="headerlink" title="5、完全注解开发"></a>5、完全注解开发</h5><h6 id="（1）创建配置类，替代-xml-配置文件"><a href="#（1）创建配置类，替代-xml-配置文件" class="headerlink" title="（1）创建配置类，替代 xml 配置文件"></a>（1）创建配置类，替代 xml 配置文件</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.atguigu.dao&quot;,&quot;com.atguigu.service&quot;&#125;)</span><span class="comment">//多个扫描，数组格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="（2）编写测试类"><a href="#（2）编写测试类" class="headerlink" title="（2）编写测试类"></a>（2）编写测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//加载配置类  AnnotationConfigApplicationContext 读取配置java类</span></span><br><span class="line"> ApplicationContext context=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"> System.out.println(userService);</span><br><span class="line"> userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean的生命周期管理(初始化Bean和销毁Bean方法改写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bookDao初始化....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bookDao销毁....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ApplicationContext不具备销毁方法，故用AnnotationConfigApplicationContext</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AnnotationConfigApplicationContext c=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDaoImpl</span> <span class="variable">bean</span> <span class="operator">=</span> c.getBean(BookDaoImpl.class);</span><br><span class="line">        bean.save();</span><br><span class="line">        c.close();<span class="comment">//这样就能执行我们对于bean的销毁操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="6、基于注解方式实现属性注入"><a href="#6、基于注解方式实现属性注入" class="headerlink" title="6、基于注解方式实现属性注入"></a>6、基于注解方式实现属性注入</h5><h6 id="（1）-Autowired：根据属性类型进行自动装配"><a href="#（1）-Autowired：根据属性类型进行自动装配" class="headerlink" title="（1）@Autowired：根据属性类型进行自动装配"></a>（1）@Autowired：根据属性类型进行自动装配</h6><p> 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解</p><p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//定义 dao 类型属性</span></span><br><span class="line"> <span class="comment">//不需要添加 set 方法</span></span><br><span class="line"> <span class="comment">//添加注入属性注解</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line"> userDao.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dao实现类</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">//@Repository(value = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao add.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动装配基于反射设计创建对象并暴力反射对应属性为私有化属性初始化数据，因此无需提供setter方法</strong></p><p><strong>自动装配建议使用无参构造器方法创建对象(默认)，如果不提供对应构造方法，请提供唯一的构造方法</strong></p><h6 id="（2）-Qualifier：根据名称进行注入，这个-Qualifier-注解的使用，和上面-Autowired-一起使用"><a href="#（2）-Qualifier：根据名称进行注入，这个-Qualifier-注解的使用，和上面-Autowired-一起使用" class="headerlink" title="（2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用"></a>（2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//开启指定名称装配bean</span></span><br><span class="line"><span class="comment">//根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！）</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><h6 id="（3）-Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）"><a href="#（3）-Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）" class="headerlink" title="（3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）"></a>（3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Resource //根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><h6 id="（4）-Value：注入普通类型属性"><a href="#（4）-Value：注入普通类型属性" class="headerlink" title="（4）@Value：注入普通类型属性"></a>（4）@Value：注入普通类型属性</h6><p>情况一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name</span><br></pre></td></tr></table></figure><p>情况二：加载properties文件 注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@PropertySource注解加载properties文件</span></span><br><span class="line"><span class="comment">//在Spring配置类中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.kk&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>路径只支持单一文件配置，多文件使用数组格式配置，不允许使用通配符</strong>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name</span><br></pre></td></tr></table></figure><h5 id="7-注解开发管理第三方Bean"><a href="#7-注解开发管理第三方Bean" class="headerlink" title="7.注解开发管理第三方Bean"></a>7.注解开发管理第三方Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="comment">//1.定义一个方法管理相关里的第三方Bean</span></span><br><span class="line">    <span class="comment">//2.添加注解@Bean表示该方法返回值是一个bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource=<span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;457631&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不建议全部都写入配置类里：应使用独立配置类管理第三方bean</p><p>将独立的配置类加入核心配置类：</p><p>方式一：导入式（推荐使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//相关配置</span></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用@Import注解手动加入配置类到核心配置，此注解只能添加一次，多个数据用数组格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.kk&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：扫描式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//相关配置</span></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用@ComponentScan注解扫描配置类所在的包，加载对应的配置类信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.kk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三方Bean简单类型依赖注入：用成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Vlaue(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Vlaue(&quot;jdbc:mysql://localhost:3306/db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Vlaue(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="meta">@Vlaue(&quot;457631&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource=<span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;457631&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第三方Bean引用类型注入：用方法形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>&#123;</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        DruidDataSource druidDataSource=<span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="comment">//相关配置</span></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;IOC-操作-Bean-管理-基于注解方式&quot;&gt;&lt;a href=&quot;#IOC-操作-Bean-管理-基于注解方式&quot; class=&quot;headerlink&quot; title=&quot;IOC 操作 Bean 管理(基于注解方式)&quot;&gt;&lt;/a&gt;IOC 操作 Bean 管理(基于注解方式)</summary>
      
    
    
    
    <category term="Spring" scheme="https://kksinher.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://kksinher.github.io/tags/Spring/"/>
    
    <category term="Ioc容器" scheme="https://kksinher.github.io/tags/Ioc%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Bean" scheme="https://kksinher.github.io/tags/Bean/"/>
    
    <category term="注解" scheme="https://kksinher.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Learn(二)</title>
    <link href="https://kksinher.github.io/2022/11/01/Spring-Learn2/"/>
    <id>https://kksinher.github.io/2022/11/01/Spring-Learn2/</id>
    <published>2022-11-01T11:15:23.000Z</published>
    <updated>2023-02-27T15:30:32.553Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring框架学习-二-—Ioc容器—Bean管理——基于XML（续集）"><a href="#Spring框架学习-二-—Ioc容器—Bean管理——基于XML（续集）" class="headerlink" title="Spring框架学习(二)—Ioc容器—Bean管理——基于XML（续集）"></a>Spring框架学习(二)—Ioc容器—Bean管理——基于XML（续集）</h4><h5 id="1、IOC-操作-Bean-管理（FactoryBean）"><a href="#1、IOC-操作-Bean-管理（FactoryBean）" class="headerlink" title="1、IOC 操作 Bean 管理（FactoryBean）"></a>1、<strong>IOC 操作 Bean 管理（FactoryBean）</strong></h5><h6 id="Spring-有两种类型-bean，一种普通-bean，另外一种工厂-bean（FactoryBean）"><a href="#Spring-有两种类型-bean，一种普通-bean，另外一种工厂-bean（FactoryBean）" class="headerlink" title="Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）"></a>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</h6><p> <strong>普通 bean：在配置文件中定义 bean 类型就是返回类型</strong></p><p> <strong>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.factorybean.MyBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line"> <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);<span class="comment">//返回值类型可以不是定义的bean类型！</span></span><br><span class="line"> System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、IOC-操作-Bean-管理（bean-作用域）"><a href="#2、IOC-操作-Bean-管理（bean-作用域）" class="headerlink" title="2、IOC 操作 Bean 管理（bean 作用域）"></a>2、IOC 操作 Bean 管理（bean 作用域）</h5><p> 在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：</p><p>（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p><p>（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="comment">&lt;!--设置为多实例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）singleton 和 prototype 区别</p><p> a）singleton 单实例，prototype 多实例</p><p> b）设置 scope 值是 singleton 时候，<strong>加载 spring 配置文件时候就会创建单实例对象</strong> ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，<strong>在调用 getBean 方法时候创建多实例对象</strong></p><h5 id="3、IOC-操作-Bean-管理（bean-生命周期）"><a href="#3、IOC-操作-Bean-管理（bean-生命周期）" class="headerlink" title="3、IOC 操作 Bean 管理（bean 生命周期）"></a>3、IOC 操作 Bean 管理（bean 生命周期）</h5><h6 id="1、生命周期-：从对象创建到对象销毁的过程"><a href="#1、生命周期-：从对象创建到对象销毁的过程" class="headerlink" title="1、生命周期 ：从对象创建到对象销毁的过程"></a>1、生命周期 ：从对象创建到对象销毁的过程</h6><h6 id="2、bean-生命周期"><a href="#2、bean-生命周期" class="headerlink" title="2、bean 生命周期"></a>2、<strong>bean 生命周期</strong></h6><p> （1）通过构造器创建 bean 实例（无参数构造）</p><p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p><p> （3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p> （4）bean 可以使用了（对象获取到了）</p><p> （5）当容器关闭前触发bean的销毁（需要进行配置销毁的方法）</p><p>或：</p><p><strong>·</strong> 初始化容器</p><p>1.创建对象（内存分配）</p><p>2.执行构造方法</p><p>3.执行属性注入（set操作）</p><p><strong>4.执行bean的初始化方法</strong></p><p><strong>·</strong> 使用bean</p><p>1.执行业务</p><p><strong>·</strong> 关闭/销毁容器</p><p><strong>1.执行bean的销毁方法</strong></p><h6 id="3、演示-bean-生命周期-两种方式-："><a href="#3、演示-bean-生命周期-两种方式-：" class="headerlink" title="3、演示 bean 生命周期(两种方式) ："></a>3、演示 bean 生命周期(两种方式) ：</h6><p>（1）手动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line"> <span class="comment">//无参数构造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第一步 执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> String oname;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.oname = oname;</span><br><span class="line"> System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;<span class="comment">//创建后置处理器实现类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件的bean参数配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><span class="comment">&lt;!--配置初始化方法和销毁方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--这里就是通过set方式（注入属性）赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean3</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ApplicationContext context =</span></span><br><span class="line"><span class="comment">// new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);</span></span><br><span class="line"><span class="comment">//要想看到销毁方法的执行，必须关闭IoC容器，使用ClassPathXmlApplication这个实现类</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line"><span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">System.out.println(orders);</span><br><span class="line"><span class="comment">//(1)手动让 bean 实例销毁 强行关闭容器</span></span><br><span class="line">context.close();</span><br><span class="line">   <span class="comment">//(2)自动关闭 让JVM关闭前先关闭IoC容器 任何位置都可以 从而让bean实例销毁</span></span><br><span class="line">   <span class="comment">//context.registerShutdownHook(); //注册关闭钩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）按照Spring的格式来写(实现<strong>InitializingBean</strong>, <strong>DisposableBean</strong>  接口)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookService save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookService bean 销毁操作 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookService bean 初始化操作 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ClassPathXmlApplicationContext b=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//(2)自动关闭 让JVM关闭前先关闭IoC容器 任何位置都可以 从而让bean实例销毁</span></span><br><span class="line">    b.registerShutdownHook(); <span class="comment">//注册关闭钩子</span></span><br><span class="line">    <span class="type">BookService</span> <span class="variable">service</span> <span class="operator">=</span>(BookService) b.getBean(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">    service.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、bean-的后置处理器，bean-生命周期有七步-（正常生命周期为五步，而配置后置处理器后为七步）"><a href="#4、bean-的后置处理器，bean-生命周期有七步-（正常生命周期为五步，而配置后置处理器后为七步）" class="headerlink" title="4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）"></a>4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）</h6><p> （1）通过构造器创建 bean 实例（无参数构造）</p><p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p><p> （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p><p> （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p> （5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p><p> （6）bean 可以使用了（对象获取到了）</p><p> （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><h5 id="4、IOC-操作-Bean-管理-外部属性文件"><a href="#4、IOC-操作-Bean-管理-外部属性文件" class="headerlink" title="4、IOC 操作 Bean 管理(外部属性文件)"></a>4、IOC 操作 Bean 管理(外部属性文件)</h5><h6 id="方式一：直接配置数据库信息-：（1）配置Druid（德鲁伊）连接池-（2）引入Druid（德鲁伊）连接池依赖-jar-包"><a href="#方式一：直接配置数据库信息-：（1）配置Druid（德鲁伊）连接池-（2）引入Druid（德鲁伊）连接池依赖-jar-包" class="headerlink" title="方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包"></a>方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="方式二：引入外部属性文件配置数据库连接池"><a href="#方式二：引入外部属性文件配置数据库连接池" class="headerlink" title="方式二：引入外部属性文件配置数据库连接池"></a>方式二：引入外部属性文件配置数据库连接池</h6><p>（1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）</p><pre><code>prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/userDbprop.userName=rootprop.password=root</code></pre><p>（2）把外部 properties 属性文件引入到 spring 配置文件中 —— 引入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><span class="comment">&lt;!--引入context名称空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5-自动装配"><a href="#5-自动装配" class="headerlink" title="5.自动装配"></a>5.自动装配</h5><p>配置中使用bean标签autowire属性设置自动装配的类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    自动装配 autowire属性：byType按类型 byName按名称  要求dao的bean只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.BookServiceImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    自动装配 autowire属性：byType按类型 byName按名称  当dao的bean有多个时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.BookServiceImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byNmae&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>自动装配使用引用类型依赖注入，不能对简单类型进行操作</p><p>使用自动装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</p><p>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</p><p><strong>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配失效</strong></p><h5 id="6-管理第三方Bean"><a href="#6-管理第三方Bean" class="headerlink" title="6.管理第三方Bean"></a>6.管理第三方Bean</h5><p>导入druid的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置数据源对象作为Spring管理的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    管理DruidDataSource对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;457631&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="7-加载properties文件"><a href="#7-加载properties文件" class="headerlink" title="7.加载properties文件"></a>7.加载properties文件</h5><p>（1）新增context命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=</span></span><br><span class="line"><span class="tag">               <span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）使用context空间加载properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property-placeholder表示占位符 system-properties-mode属性规定是否加载系统属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个配置文件时 规范模式--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>（3）使用属性占位符${}读取properties文件中的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</p><p>ApplicationContext接口是Spring容器核心接口，初始化bean时立即加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--改为延迟加载 lazy-init属性控制bean延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ApplicationContext接口提供基础的bean操作相关方法，通过接口扩展其他功能</p><p>ApplicationContext接口常用初始类：</p><p>​    ClassPathXmlApplicationContext</p><p>​    FileSystemXmlApplicationContext</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Spring框架学习-二-—Ioc容器—Bean管理——基于XML（续集）&quot;&gt;&lt;a href=&quot;#Spring框架学习-二-—Ioc容器—Bean管理——基于XML（续集）&quot; class=&quot;headerlink&quot; title=&quot;Spring框架学习(二)—Ioc容</summary>
      
    
    
    
    <category term="Spring" scheme="https://kksinher.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://kksinher.github.io/tags/Spring/"/>
    
    <category term="Ioc容器" scheme="https://kksinher.github.io/tags/Ioc%E5%AE%B9%E5%99%A8/"/>
    
    <category term="XML" scheme="https://kksinher.github.io/tags/XML/"/>
    
    <category term="Bean" scheme="https://kksinher.github.io/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Learn(一)</title>
    <link href="https://kksinher.github.io/2022/11/01/Spring-Learn1/"/>
    <id>https://kksinher.github.io/2022/11/01/Spring-Learn1/</id>
    <published>2022-11-01T11:15:23.000Z</published>
    <updated>2023-02-27T15:30:18.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring框架学习-一-——Ioc容器管理"><a href="#Spring框架学习-一-——Ioc容器管理" class="headerlink" title="Spring框架学习(一)——Ioc容器管理"></a>Spring框架学习(一)——Ioc容器管理</h3><h4 id="一、Spring——IOC（Inversion-of-Control）控制反转"><a href="#一、Spring——IOC（Inversion-of-Control）控制反转" class="headerlink" title="一、Spring——IOC（Inversion of Control）控制反转"></a>一、Spring——<a href="https://so.csdn.net/so/search?q=IOC&spm=1001.2101.3001.7020">IOC</a>（Inversion of Control）控制反转</h4><p><strong>思想：</strong>使用对象时，由主动产生对象转换为由<strong>外部</strong>提供对象，此过程中对象创建控制权由程序转移到外部</p><p><strong>Ioc:</strong>    Spring提供了一个容器。称为<strong>Ioc容器</strong>，用来充当Ioc思想中的“<strong>外部</strong>”，Ioc负责对象的创建，初始化对象等一系列工作</p><p><strong>Bean</strong>:   被创建或管理的对象称为Bean</p><p>Bean的本质上就是对象，实例化bean的三种方式：</p><p>1.构造方法实例化Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用静态工厂实例化Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>3.使用实例工厂实例化Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.factory.UserDaoFactory&quot;</span>/&gt;</span>  配合使用，无实际意义</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userDaoFactory&quot;</span>/&gt;</span>方法名不固定，每次需要配置</span><br></pre></td></tr></table></figure><p>优化如下：</p><p>4.使用FactoryBean实例化Bean(掌握)———-3.变种</p><p>第一步创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt;&#123;</span><br><span class="line">    <span class="comment">//得到bean实例</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); <span class="comment">//返回你想要的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到bean类型</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType()&#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;  <span class="comment">//对象类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设定单例或非单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//true代表是单例对象，false代表是非单例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.factory.UserDaoFactoryBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DI(Dependncy Injection) ：</strong>在容器中建立bean与bean之间的依赖关系，称为<strong>依赖注入</strong></p><h5 id="1、什么是IOC（控制反转）"><a href="#1、什么是IOC（控制反转）" class="headerlink" title="1、什么是IOC（控制反转）"></a><strong>1、什么是IOC（控制反转）</strong></h5><p> a）把对象创建和对象之间的调用过程，交给Spring进行管理</p><p> b）使用IOC目的：为了<strong>降低耦合度</strong></p><h5 id="2、IOC底层"><a href="#2、IOC底层" class="headerlink" title="2、IOC底层"></a><strong>2、IOC底层</strong></h5><p> a）XML 解析、工厂模式、反射</p><h5 id="3、Spring提供的IOC容器实现的两种方式（两个接口）"><a href="#3、Spring提供的IOC容器实现的两种方式（两个接口）" class="headerlink" title="3、Spring提供的IOC容器实现的两种方式（两个接口）"></a><strong>3、Spring提供的IOC容器实现的两种方式（两个接口）</strong></h5><p> a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取(或使用)对象时才会创建对象。）</p><p> b）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！</p><h4 id="二、IOC容器-Bean管理"><a href="#二、IOC容器-Bean管理" class="headerlink" title="二、IOC容器-Bean管理"></a>二、IOC容器-Bean管理</h4><h5 id="1、IOC操作Bean管理"><a href="#1、IOC操作Bean管理" class="headerlink" title="1、IOC操作Bean管理"></a>1、IOC操作Bean管理</h5><p> a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性</p><h5 id="2、基于XML配置文件创建对象"><a href="#2、基于XML配置文件创建对象" class="headerlink" title="2、基于XML配置文件创建对象"></a>2、基于XML配置文件创建对象</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 配置User对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、基于XML方式注入属性（DI：依赖注入（注入属性））"><a href="#3、基于XML方式注入属性（DI：依赖注入（注入属性））" class="headerlink" title="3、基于XML方式注入属性（DI：依赖注入（注入属性））"></a>3、基于XML方式注入属性（DI：依赖注入（注入属性））</h5><p>引入：向一个类传递数据方式有几种？   <strong>1.普通方法（set方法）      2.构造方法</strong></p><p>注入的数据类型：<strong>1.引用类型   2.简单类型(基本数据类型和String)</strong></p><p>故，依赖注入方式分四个情况：</p><p><strong>1.setter注入：  （1）简单类型  （2）引用类型</strong></p><p><strong>2.构造器注入：   （1）简单类型  （2）引用类型</strong></p><h6 id="a）setter方式注入简单类型"><a href="#a）setter方式注入简单类型" class="headerlink" title="a）setter方式注入简单类型"></a>a）setter方式注入简单类型</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在bean中定义引用类型并提供可访问的set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        <span class="comment">//创建属性</span></span><br><span class="line">        <span class="keyword">private</span> String bname;</span><br><span class="line">        <span class="comment">//创建属性对应的set方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bname = bname;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在配置中使用property标签value属性注入简单类型数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property完成属性注入</span></span><br><span class="line"><span class="comment">        name：类里面属性名称</span></span><br><span class="line"><span class="comment">        value：向属性注入的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="b）setter注入引用数据类型"><a href="#b）setter注入引用数据类型" class="headerlink" title="b）setter注入引用数据类型"></a>b）setter注入引用数据类型</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        System.out.println(<span class="string">&quot;service set ...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    7.配置service与dao的关系</span></span><br><span class="line"><span class="comment">property属性表示配置当前bean的属性、</span></span><br><span class="line"><span class="comment">name属性表示配置哪一个具体的属性 ref属性表示参照哪一个bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="c）有参构造器注入简单数据类型"><a href="#c）有参构造器注入简单数据类型" class="headerlink" title="c）有参构造器注入简单数据类型"></a>c）有参构造器注入简单数据类型</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在bean中定义引用类型属性并提供可访问的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//有参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">(String oname,String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置中使用constructor-arg标签ref属性注入引用类型对象 顺序不影响  标准书写 耦合度高--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;China！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优化如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决形参名称问题，与形参名不耦合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">10</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决参数类型重复，使用位置解决参数匹配--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;China！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="d）有参构造注入引用数据类型"><a href="#d）有参构造注入引用数据类型" class="headerlink" title="d）有参构造注入引用数据类型"></a>d）有参构造注入引用数据类型</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao dao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao=bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中使用constructor-arg标签ref属性注入引用类型对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="e）p名称空间注入（了解即可）"><a href="#e）p名称空间注入（了解即可）" class="headerlink" title="e）p名称空间注入（了解即可）"></a>e）p名称空间注入（了解即可）</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、添加p名称空间在配置文件头部--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>&lt;!<span class="attr">--在这里添加一行p--</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2、在bean标签进行属性注入（算是set方式注入的简化操作）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;very&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;good&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</p><p>2.可选依赖使用setter注入进行，灵活性太强</p><p>3.Spring框架提倡使用构造器，第三方框架内部i大多采用构造器注入的形式，相对严谨</p><p>4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖注入</p><p>5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</p><p><strong>6.自己开发的模块推荐使用setter注入</strong></p><h5 id="4、注入空值和特殊符号"><a href="#4、注入空值和特殊符号" class="headerlink" title="4、注入空值和特殊符号"></a>4、注入空值和特殊符号</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--（1）null值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="comment">&lt;!--属性里边添加一个null标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--（2）特殊符号赋值--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--属性值包含特殊符号</span></span><br><span class="line"><span class="comment">       a 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment">       b 把带特殊符号内容写到CDATA</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5、注入属性-外部bean"><a href="#5、注入属性-外部bean" class="headerlink" title="5、注入属性-外部bean"></a>5、注入属性-外部bean</h5><p> a）创建两个类service和dao类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;<span class="comment">//service类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建UserDao类型属性，生成set方法</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add...............&quot;</span>);</span><br><span class="line">        userDao.update();<span class="comment">//调用dao方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;<span class="comment">//dao类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao update...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> b）在spring配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 service和dao对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入userDao对象</span></span><br><span class="line"><span class="comment">        name属性：类里面属性名称</span></span><br><span class="line"><span class="comment">        ref属性：创建userDao对象bean标签id值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6、基于XML方式注入内部bean和级联赋值"><a href="#6、基于XML方式注入内部bean和级联赋值" class="headerlink" title="6、基于XML方式注入内部bean和级联赋值"></a>6、基于XML方式注入内部bean和级联赋值</h5><h6 id="a）注入属性-内部bean"><a href="#a）注入属性-内部bean" class="headerlink" title="a）注入属性-内部bean"></a>a）注入属性-内部bean</h6><p>（1）一对多关系：部门和员工<br>一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多）<br>（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//员工属于某一个部门，使用对象形式表示</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在spring配置文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Andy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span><span class="comment">&lt;!--内部bean赋值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;宣传部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="b）注入属性-级联赋值"><a href="#b）注入属性-级联赋值" class="headerlink" title="b）注入属性-级联赋值"></a>b）注入属性-级联赋值</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一：级联赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Andy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;公关部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式二：生成dept的get方法（get方法必须有！！）</span></span><br><span class="line">   <span class="keyword">public</span> Dept <span class="title function_">getDept</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> dept;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jams&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="7、IOC-操作-Bean-管理——xml-注入集合属性"><a href="#7、IOC-操作-Bean-管理——xml-注入集合属性" class="headerlink" title="7、IOC 操作 Bean 管理——xml 注入集合属性"></a><strong>7、IOC 操作 Bean 管理——xml 注入集合属性</strong></h5><p>1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] courses;</span><br><span class="line">    <span class="comment">//2 list集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//3 map集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line">    <span class="comment">//4 set集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--（2）在 spring 配置文件进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--list类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--map类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="8、在集合里面设置对象类型值"><a href="#8、在集合里面设置对象类型值" class="headerlink" title="8、在集合里面设置对象类型值"></a>8、在集合里面设置对象类型值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生所学多门课程</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Course&gt; courseList;<span class="comment">//创建集合</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourseList</span><span class="params">(List&lt;Course&gt; courseList)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.courseList = courseList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个course对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入list集合类型，值是对象--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一步：在 spring 配置文件中引入名称空间 util--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span> &lt;!<span class="attr">--添加util名称空间--</span>&gt;</span></span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;  <span class="comment">&lt;!--添加util名称空间--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--第二步：使用 util 标签完成 list 集合注入提取--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--把集合注入部分提取出来--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--1 提取list集合类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--2 提取list集合类型属性注入使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring框架学习-一-——Ioc容器管理&quot;&gt;&lt;a href=&quot;#Spring框架学习-一-——Ioc容器管理&quot; class=&quot;headerlink&quot; title=&quot;Spring框架学习(一)——Ioc容器管理&quot;&gt;&lt;/a&gt;Spring框架学习(一)——Ioc容器</summary>
      
    
    
    
    <category term="Spring" scheme="https://kksinher.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://kksinher.github.io/tags/Spring/"/>
    
    <category term="Ioc容器" scheme="https://kksinher.github.io/tags/Ioc%E5%AE%B9%E5%99%A8/"/>
    
    <category term="DI" scheme="https://kksinher.github.io/tags/DI/"/>
    
  </entry>
  
</feed>
